{
  "version": 3,
  "sources": ["../../luaparse/luaparse.js"],
  "sourcesContent": ["/* global exports:true, module:true, require:true, define:true, global:true */\n\n(function (root, name, factory) {\n  'use strict';\n\n  // Used to determine if values are of the language type `Object`\n  var objectTypes = {\n        'function': true\n      , 'object': true\n    }\n    // Detect free variable `exports`\n    , freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports\n    // Detect free variable `module`\n    , freeModule = objectTypes[typeof module] && module && !module.nodeType && module\n    // Detect free variable `global`, from Node.js or Browserified code, and\n    // use it as `window`\n    , freeGlobal = freeExports && freeModule && typeof global === 'object' && global\n    // Detect the popular CommonJS extension `module.exports`\n    , moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /* istanbul ignore else */\n  if (freeGlobal && (freeGlobal.global === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.window === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Some AMD build optimizers, like r.js, check for specific condition\n  // patterns like the following:\n  /* istanbul ignore if */\n  if (typeof define === 'function' &&\n      /* istanbul ignore next */ typeof define.amd === 'object' &&\n      /* istanbul ignore next */ define.amd) {\n    // defined as an anonymous module.\n    define(['exports'], factory);\n    // In case the source has been processed and wrapped in a define module use\n    // the supplied `exports` object.\n    if (freeExports && moduleExports) factory(freeModule.exports);\n  }\n  // check for `exports` after `define` in case a build optimizer adds an\n  // `exports` object\n  else /* istanbul ignore else */ if (freeExports && freeModule) {\n    // in Node.js or RingoJS v0.8.0+\n    /* istanbul ignore else */\n    if (moduleExports) factory(freeModule.exports);\n    // in RingoJS v0.7.0-\n    else factory(freeExports);\n  }\n  // in a browser or Rhino\n  else {\n    factory((root[name] = {}));\n  }\n}(this, 'luaparse', function (exports) {\n  'use strict';\n\n  exports.version = \"0.3.1\";\n\n  var input, options, length, features, encodingMode;\n\n  // Options can be set either globally on the parser object through\n  // defaultOptions, or during the parse call.\n  var defaultOptions = exports.defaultOptions = {\n    // Explicitly tell the parser when the input ends.\n      wait: false\n    // Store comments as an array in the chunk object.\n    , comments: true\n    // Track identifier scopes by adding an isLocal attribute to each\n    // identifier-node.\n    , scope: false\n    // Store location information on each syntax node as\n    // `loc: { start: { line, column }, end: { line, column } }`.\n    , locations: false\n    // Store the start and end character locations on each syntax node as\n    // `range: [start, end]`.\n    , ranges: false\n    // A callback which will be invoked when a syntax node has been completed.\n    // The node which has been created will be passed as the only parameter.\n    , onCreateNode: null\n    // A callback which will be invoked when a new scope is created.\n    , onCreateScope: null\n    // A callback which will be invoked when the current scope is destroyed.\n    , onDestroyScope: null\n    // A callback which will be invoked when a local variable is declared in the current scope.\n    // The variable's name will be passed as the only parameter\n    , onLocalDeclaration: null\n    // The version of Lua targeted by the parser (string; allowed values are\n    // '5.1', '5.2', '5.3').\n    , luaVersion: '5.1'\n    // Encoding mode: how to interpret code units higher than U+007F in input\n    , encodingMode: 'none'\n  };\n\n  function encodeUTF8(codepoint, highMask) {\n    highMask = highMask || 0;\n\n    if (codepoint < 0x80) {\n      return String.fromCharCode(codepoint);\n    } else if (codepoint < 0x800) {\n      return String.fromCharCode(\n        highMask | 0xc0 |  (codepoint >>  6)        ,\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else if (codepoint < 0x10000) {\n      return String.fromCharCode(\n        highMask | 0xe0 |  (codepoint >> 12)        ,\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else /* istanbul ignore else */ if (codepoint < 0x110000) {\n      return String.fromCharCode(\n        highMask | 0xf0 |  (codepoint >> 18)        ,\n        highMask | 0x80 | ((codepoint >> 12) & 0x3f),\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else {\n      // TODO: Lua 5.4 allows up to six-byte sequences, as in UTF-8:1993\n      return null;\n    }\n  }\n\n  function toHex(num, digits) {\n    var result = num.toString(16);\n    while (result.length < digits)\n      result = '0' + result;\n    return result;\n  }\n\n  function checkChars(rx) {\n    return function (s) {\n      var m = rx.exec(s);\n      if (!m)\n        return s;\n      raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());\n    };\n  }\n\n  var encodingModes = {\n    // `pseudo-latin1` encoding mode: assume the input was decoded with the latin1 encoding\n    // WARNING: latin1 does **NOT** mean cp1252 here like in the bone-headed WHATWG standard;\n    // it means true ISO/IEC 8859-1 identity-mapped to Basic Latin and Latin-1 Supplement blocks\n    'pseudo-latin1': {\n      fixup: checkChars(/[^\\x00-\\xff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint);\n      },\n    },\n\n    // `x-user-defined` encoding mode: assume the input was decoded with the WHATWG `x-user-defined` encoding\n    'x-user-defined': {\n      fixup: checkChars(/[^\\x00-\\x7f\\uf780-\\uf7ff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        if (value >= 0x80)\n          return String.fromCharCode(value | 0xf700);\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint, 0xf700);\n      }\n    },\n\n    // `none` encoding mode: disregard intrepretation of string literals, leave identifiers as-is\n    'none': {\n      discardStrings: true,\n      fixup: function (s) {\n        return s;\n      },\n      encodeByte: function (value) {\n        return '';\n      },\n      encodeUTF8: function (codepoint) {\n        return '';\n      }\n    }\n  };\n\n  // The available tokens expressed as enum flags so they can be checked with\n  // bitwise operations.\n\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\n    , NilLiteral = 128, VarargLiteral = 256;\n\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\n  };\n\n  // As this parser is a bit different from luas own, the error messages\n  // will be different in some situations.\n\n  var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\''\n    , unexpectedEOF: 'unexpected symbol near \\'<eof>\\''\n    , expected: '\\'%1\\' expected near \\'%2\\''\n    , expectedToken: '%1 expected near \\'%2\\''\n    , unfinishedString: 'unfinished string near \\'%1\\''\n    , malformedNumber: 'malformed number near \\'%1\\''\n    , decimalEscapeTooLarge: 'decimal escape too large near \\'%1\\''\n    , invalidEscape: 'invalid escape sequence near \\'%1\\''\n    , hexadecimalDigitExpected: 'hexadecimal digit expected near \\'%1\\''\n    , braceExpected: 'missing \\'%1\\' near \\'%2\\''\n    , tooLargeCodepoint: 'UTF-8 value too large near \\'%1\\''\n    , unfinishedLongString: 'unfinished long string (starting at line %1) near \\'%2\\''\n    , unfinishedLongComment: 'unfinished long comment (starting at line %1) near \\'%2\\''\n    , ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \\'%1\\''\n    , noLoopToBreak: 'no loop to break near \\'%1\\''\n    , labelAlreadyDefined: 'label \\'%1\\' already defined on line %2'\n    , labelNotVisible: 'no visible label \\'%1\\' for <goto>'\n    , gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \\'%2\\''\n    , cannotUseVararg: 'cannot use \\'...\\' outside a vararg function near \\'%1\\''\n    , invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'\n  };\n\n  // ### Abstract Syntax Tree\n  //\n  // The default AST structure is inspired by the Mozilla Parser API but can\n  // easily be customized by overriding these functions.\n\n  var ast = exports.ast = {\n      labelStatement: function(label) {\n      return {\n          type: 'LabelStatement'\n        , label: label\n      };\n    }\n\n    , breakStatement: function() {\n      return {\n          type: 'BreakStatement'\n      };\n    }\n\n    , gotoStatement: function(label) {\n      return {\n          type: 'GotoStatement'\n        , label: label\n      };\n    }\n\n    , returnStatement: function(args) {\n      return {\n          type: 'ReturnStatement'\n        , 'arguments': args\n      };\n    }\n\n    , ifStatement: function(clauses) {\n      return {\n          type: 'IfStatement'\n        , clauses: clauses\n      };\n    }\n    , ifClause: function(condition, body) {\n      return {\n          type: 'IfClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseifClause: function(condition, body) {\n      return {\n          type: 'ElseifClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseClause: function(body) {\n      return {\n          type: 'ElseClause'\n        , body: body\n      };\n    }\n\n    , whileStatement: function(condition, body) {\n      return {\n          type: 'WhileStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , doStatement: function(body) {\n      return {\n          type: 'DoStatement'\n        , body: body\n      };\n    }\n\n    , repeatStatement: function(condition, body) {\n      return {\n          type: 'RepeatStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , localStatement: function(variables, init) {\n      return {\n          type: 'LocalStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , assignmentStatement: function(variables, init) {\n      return {\n          type: 'AssignmentStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , callStatement: function(expression) {\n      return {\n          type: 'CallStatement'\n        , expression: expression\n      };\n    }\n\n    , functionStatement: function(identifier, parameters, isLocal, body) {\n      return {\n          type: 'FunctionDeclaration'\n        , identifier: identifier\n        , isLocal: isLocal\n        , parameters: parameters\n        , body: body\n      };\n    }\n\n    , forNumericStatement: function(variable, start, end, step, body) {\n      return {\n          type: 'ForNumericStatement'\n        , variable: variable\n        , start: start\n        , end: end\n        , step: step\n        , body: body\n      };\n    }\n\n    , forGenericStatement: function(variables, iterators, body) {\n      return {\n          type: 'ForGenericStatement'\n        , variables: variables\n        , iterators: iterators\n        , body: body\n      };\n    }\n\n    , chunk: function(body) {\n      return {\n          type: 'Chunk'\n        , body: body\n      };\n    }\n\n    , identifier: function(name) {\n      return {\n          type: 'Identifier'\n        , name: name\n      };\n    }\n\n    , literal: function(type, value, raw) {\n      type = (type === StringLiteral) ? 'StringLiteral'\n        : (type === NumericLiteral) ? 'NumericLiteral'\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\n        : (type === NilLiteral) ? 'NilLiteral'\n        : 'VarargLiteral';\n\n      return {\n          type: type\n        , value: value\n        , raw: raw\n      };\n    }\n\n    , tableKey: function(key, value) {\n      return {\n          type: 'TableKey'\n        , key: key\n        , value: value\n      };\n    }\n    , tableKeyString: function(key, value) {\n      return {\n          type: 'TableKeyString'\n        , key: key\n        , value: value\n      };\n    }\n    , tableValue: function(value) {\n      return {\n          type: 'TableValue'\n        , value: value\n      };\n    }\n\n\n    , tableConstructorExpression: function(fields) {\n      return {\n          type: 'TableConstructorExpression'\n        , fields: fields\n      };\n    }\n    , binaryExpression: function(operator, left, right) {\n      var type = ('and' === operator || 'or' === operator) ?\n        'LogicalExpression' :\n        'BinaryExpression';\n\n      return {\n          type: type\n        , operator: operator\n        , left: left\n        , right: right\n      };\n    }\n    , unaryExpression: function(operator, argument) {\n      return {\n          type: 'UnaryExpression'\n        , operator: operator\n        , argument: argument\n      };\n    }\n    , memberExpression: function(base, indexer, identifier) {\n      return {\n          type: 'MemberExpression'\n        , indexer: indexer\n        , identifier: identifier\n        , base: base\n      };\n    }\n\n    , indexExpression: function(base, index) {\n      return {\n          type: 'IndexExpression'\n        , base: base\n        , index: index\n      };\n    }\n\n    , callExpression: function(base, args) {\n      return {\n          type: 'CallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , tableCallExpression: function(base, args) {\n      return {\n          type: 'TableCallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , stringCallExpression: function(base, argument) {\n      return {\n          type: 'StringCallExpression'\n        , base: base\n        , argument: argument\n      };\n    }\n\n    , comment: function(value, raw) {\n      return {\n          type: 'Comment'\n        , value: value\n        , raw: raw\n      };\n    }\n  };\n\n  // Wrap up the node object.\n\n  function finishNode(node) {\n    // Pop a `Marker` off the location-array and attach its location data.\n    if (trackLocations) {\n      var location = locations.pop();\n      location.complete();\n      location.bless(node);\n    }\n    if (options.onCreateNode) options.onCreateNode(node);\n    return node;\n  }\n\n\n  // Helpers\n  // -------\n\n  var slice = Array.prototype.slice\n    , toString = Object.prototype.toString\n    ;\n\n  var indexOf = /* istanbul ignore next */ function (array, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i] === element) return i;\n    }\n    return -1;\n  };\n\n  /* istanbul ignore else */\n  if (Array.prototype.indexOf)\n    indexOf = function (array, element) {\n      return array.indexOf(element);\n    };\n\n  // Iterate through an array of objects and return the index of an object\n  // with a matching property.\n\n  function indexOfObject(array, property, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i][property] === element) return i;\n    }\n    return -1;\n  }\n\n  // A sprintf implementation using %index (beginning at 1) to input\n  // arguments in the format string.\n  //\n  // Example:\n  //\n  //     // Unexpected function in token\n  //     sprintf('Unexpected %2 in %1.', 'token', 'function');\n\n  function sprintf(format) {\n    var args = slice.call(arguments, 1);\n    format = format.replace(/%(\\d)/g, function (match, index) {\n      return '' + args[index - 1] || /* istanbul ignore next */ '';\n    });\n    return format;\n  }\n\n  // Polyfill for `Object.assign`.\n\n  var assign = /* istanbul ignore next */ function (dest) {\n    var args = slice.call(arguments, 1)\n      , src, prop;\n\n    for (var i = 0, length = args.length; i < length; ++i) {\n      src = args[i];\n      for (prop in src)\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(src, prop)) {\n          dest[prop] = src[prop];\n        }\n    }\n\n    return dest;\n  };\n\n  /* istanbul ignore else */\n  if (Object.assign)\n    assign = Object.assign;\n\n  // ### Error functions\n\n  exports.SyntaxError = SyntaxError;\n\n  // XXX: Eliminate this function and change the error type to be different from SyntaxError.\n  // This will unfortunately be a breaking change, because some downstream users depend\n  // on the error thrown being an instance of SyntaxError. For example, the Ace editor:\n  // <https://github.com/ajaxorg/ace/blob/4c7e5eb3f5d5ca9434847be51834a4e41661b852/lib/ace/mode/lua_worker.js#L55>\n\n  function fixupError(e) {\n    /* istanbul ignore if */\n    if (!Object.create)\n      return e;\n    return Object.create(e, {\n      'line': { 'writable': true, value: e.line },\n      'index': { 'writable': true, value: e.index },\n      'column': { 'writable': true, value: e.column }\n    });\n  }\n\n  // #### Raise an exception.\n  //\n  // Raise an exception by passing a token, a string format and its paramters.\n  //\n  // The passed tokens location will automatically be added to the error\n  // message if it exists, if not it will default to the lexers current\n  // position.\n  //\n  // Example:\n  //\n  //     // [1:0] expected [ near (\n  //     raise(token, \"expected %1 near %2\", '[', token.value);\n\n  function raise(token) {\n    var message = sprintf.apply(null, slice.call(arguments, 1))\n      , error, col;\n\n    if (token === null || typeof token.line === 'undefined') {\n      col = index - lineStart + 1;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));\n      error.index = index;\n      error.line = line;\n      error.column = col;\n    } else {\n      col = token.range[0] - token.lineStart;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));\n      error.line = token.line;\n      error.index = token.range[0];\n      error.column = col;\n    }\n    throw error;\n  }\n\n  function tokenValue(token) {\n    var raw = input.slice(token.range[0], token.range[1]);\n    if (raw)\n      return raw;\n    return token.value;\n  }\n\n  // #### Raise an unexpected token error.\n  //\n  // Example:\n  //\n  //     // expected <name> near '0'\n  //     raiseUnexpectedToken('<name>', token);\n\n  function raiseUnexpectedToken(type, token) {\n    raise(token, errors.expectedToken, type, tokenValue(token));\n  }\n\n  // #### Raise a general unexpected error\n  //\n  // Usage should pass either a token object or a symbol string which was\n  // expected. We can also specify a nearby token such as <eof>, this will\n  // default to the currently active token.\n  //\n  // Example:\n  //\n  //     // Unexpected symbol 'end' near '<eof>'\n  //     unexpected(token);\n  //\n  // If there's no token in the buffer it means we have reached <eof>.\n\n  function unexpected(found) {\n    var near = tokenValue(lookahead);\n    if ('undefined' !== typeof found.type) {\n      var type;\n      switch (found.type) {\n        case StringLiteral:   type = 'string';      break;\n        case Keyword:         type = 'keyword';     break;\n        case Identifier:      type = 'identifier';  break;\n        case NumericLiteral:  type = 'number';      break;\n        case Punctuator:      type = 'symbol';      break;\n        case BooleanLiteral:  type = 'boolean';     break;\n        case NilLiteral:\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\n        case EOF:\n          return raise(found, errors.unexpectedEOF);\n      }\n      return raise(found, errors.unexpected, type, tokenValue(found), near);\n    }\n    return raise(found, errors.unexpected, 'symbol', found, near);\n  }\n\n  // Lexer\n  // -----\n  //\n  // The lexer, or the tokenizer reads the input string character by character\n  // and derives a token left-right. To be as efficient as possible the lexer\n  // prioritizes the common cases such as identifiers. It also works with\n  // character codes instead of characters as string comparisons was the\n  // biggest bottleneck of the parser.\n  //\n  // If `options.comments` is enabled, all comments encountered will be stored\n  // in an array which later will be appended to the chunk object. If disabled,\n  // they will simply be disregarded.\n  //\n  // When the lexer has derived a valid token, it will be returned as an object\n  // containing its value and as well as its position in the input string (this\n  // is always enabled to provide proper debug messages).\n  //\n  // `lex()` starts lexing and returns the following token in the stream.\n\n  var index\n    , token\n    , previousToken\n    , lookahead\n    , comments\n    , tokenStart\n    , line\n    , lineStart;\n\n  exports.lex = lex;\n\n  function lex() {\n    skipWhiteSpace();\n\n    // Skip comments beginning with --\n    while (45 === input.charCodeAt(index) &&\n           45 === input.charCodeAt(index + 1)) {\n      scanComment();\n      skipWhiteSpace();\n    }\n    if (index >= length) return {\n        type : EOF\n      , value: '<eof>'\n      , line: line\n      , lineStart: lineStart\n      , range: [index, index]\n    };\n\n    var charCode = input.charCodeAt(index)\n      , next = input.charCodeAt(index + 1);\n\n    // Memorize the range index where the token begins.\n    tokenStart = index;\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n\n    switch (charCode) {\n      case 39: case 34: // '\"\n        return scanStringLiteral();\n\n      case 48: case 49: case 50: case 51: case 52: case 53:\n      case 54: case 55: case 56: case 57: // 0-9\n        return scanNumericLiteral();\n\n      case 46: // .\n        // If the dot is followed by a digit it's a float.\n        if (isDecDigit(next)) return scanNumericLiteral();\n        if (46 === next) {\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n          return scanPunctuator('..');\n        }\n        return scanPunctuator('.');\n\n      case 61: // =\n        if (61 === next) return scanPunctuator('==');\n        return scanPunctuator('=');\n\n      case 62: // >\n        if (features.bitwiseOperators)\n          if (62 === next) return scanPunctuator('>>');\n        if (61 === next) return scanPunctuator('>=');\n        return scanPunctuator('>');\n\n      case 60: // <\n        if (features.bitwiseOperators)\n          if (60 === next) return scanPunctuator('<<');\n        if (61 === next) return scanPunctuator('<=');\n        return scanPunctuator('<');\n\n      case 126: // ~\n        if (61 === next) return scanPunctuator('~=');\n        if (!features.bitwiseOperators)\n          break;\n        return scanPunctuator('~');\n\n      case 58: // :\n        if (features.labels)\n          if (58 === next) return scanPunctuator('::');\n        return scanPunctuator(':');\n\n      case 91: // [\n        // Check for a multiline string, they begin with [= or [[\n        if (91 === next || 61 === next) return scanLongStringLiteral();\n        return scanPunctuator('[');\n\n      case 47: // /\n        // Check for integer division op (//)\n        if (features.integerDivision)\n          if (47 === next) return scanPunctuator('//');\n        return scanPunctuator('/');\n\n      case 38: case 124: // & |\n        if (!features.bitwiseOperators)\n          break;\n\n        /* fall through */\n      case 42: case 94: case 37: case 44: case 123: case 125:\n      case 93: case 40: case 41: case 59: case 35: case 45:\n      case 43: // * ^ % , { } ] ( ) ; # - +\n        return scanPunctuator(input.charAt(index));\n    }\n\n    return unexpected(input.charAt(index));\n  }\n\n  // Whitespace has no semantic meaning in lua so simply skip ahead while\n  // tracking the encounted newlines. Any kind of eol sequence is counted as a\n  // single line.\n\n  function consumeEOL() {\n    var charCode = input.charCodeAt(index)\n      , peekCharCode = input.charCodeAt(index + 1);\n\n    if (isLineTerminator(charCode)) {\n      // Count \\n\\r and \\r\\n as one newline.\n      if (10 === charCode && 13 === peekCharCode) ++index;\n      if (13 === charCode && 10 === peekCharCode) ++index;\n      ++line;\n      lineStart = ++index;\n\n      return true;\n    }\n    return false;\n  }\n\n  function skipWhiteSpace() {\n    while (index < length) {\n      var charCode = input.charCodeAt(index);\n      if (isWhiteSpace(charCode)) {\n        ++index;\n      } else if (!consumeEOL()) {\n        break;\n      }\n    }\n  }\n\n  // Identifiers, keywords, booleans and nil all look the same syntax wise. We\n  // simply go through them one by one and defaulting to an identifier if no\n  // previous case matched.\n\n  function scanIdentifierOrKeyword() {\n    var value, type;\n\n    // Slicing the input string is prefered before string concatenation in a\n    // loop for performance reasons.\n    while (isIdentifierPart(input.charCodeAt(++index)));\n    value = encodingMode.fixup(input.slice(tokenStart, index));\n\n    // Decide on the token type and possibly cast the value.\n    if (isKeyword(value)) {\n      type = Keyword;\n    } else if ('true' === value || 'false' === value) {\n      type = BooleanLiteral;\n      value = ('true' === value);\n    } else if ('nil' === value) {\n      type = NilLiteral;\n      value = null;\n    } else {\n      type = Identifier;\n    }\n\n    return {\n        type: type\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Once a punctuator reaches this function it should already have been\n  // validated so we simply return it as a token.\n\n  function scanPunctuator(value) {\n    index += value.length;\n    return {\n        type: Punctuator\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // A vararg literal consists of three dots.\n\n  function scanVarargLiteral() {\n    index += 3;\n    return {\n        type: VarargLiteral\n      , value: '...'\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Find the string literal by matching the delimiter marks used.\n\n  function scanStringLiteral() {\n    var delimiter = input.charCodeAt(index++)\n      , beginLine = line\n      , beginLineStart = lineStart\n      , stringStart = index\n      , string = encodingMode.discardStrings ? null : ''\n      , charCode;\n\n    for (;;) {\n      charCode = input.charCodeAt(index++);\n      if (delimiter === charCode) break;\n      // EOF or `\\n` terminates a string literal. If we haven't found the\n      // ending delimiter by now, raise an exception.\n      if (index > length || isLineTerminator(charCode)) {\n        string += input.slice(stringStart, index - 1);\n        raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));\n      }\n      if (92 === charCode) { // backslash\n        if (!encodingMode.discardStrings) {\n          var beforeEscape = input.slice(stringStart, index - 1);\n          string += encodingMode.fixup(beforeEscape);\n        }\n        var escapeValue = readEscapeSequence();\n        if (!encodingMode.discardStrings)\n          string += escapeValue;\n        stringStart = index;\n      }\n    }\n    if (!encodingMode.discardStrings) {\n      string += encodingMode.encodeByte(null);\n      string += encodingMode.fixup(input.slice(stringStart, index - 1));\n    }\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Expect a multiline string literal and return it as a regular string\n  // literal, if it doesn't validate into a valid multiline string, throw an\n  // exception.\n\n  function scanLongStringLiteral() {\n    var beginLine = line\n      , beginLineStart = lineStart\n      , string = readLongString(false);\n    // Fail if it's not a multiline literal.\n    if (false === string) raise(token, errors.expected, '[', tokenValue(token));\n\n    return {\n        type: StringLiteral\n      , value: encodingMode.discardStrings ? null : encodingMode.fixup(string)\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Numeric literals will be returned as floating-point numbers instead of\n  // strings. The raw value should be retrieved from slicing the input string\n  // later on in the process.\n  //\n  // If a hexadecimal number is encountered, it will be converted.\n\n  function scanNumericLiteral() {\n    var character = input.charAt(index)\n      , next = input.charAt(index + 1);\n\n    var literal = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\n      readHexLiteral() : readDecLiteral();\n\n    var foundImaginaryUnit = readImaginaryUnitSuffix()\n      , foundInt64Suffix = readInt64Suffix();\n\n    if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n    }\n\n    return {\n        type: NumericLiteral\n      , value: literal.value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  function readImaginaryUnitSuffix() {\n    if (!features.imaginaryNumbers) return;\n\n    // Imaginary unit number suffix is optional.\n    // See http://luajit.org/ext_ffi_api.html#literals\n    if ('iI'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function readInt64Suffix() {\n    if (!features.integerSuffixes) return;\n\n    // Int64/uint64 number suffix is optional.\n    // See http://luajit.org/ext_ffi_api.html#literals\n\n    if ('uU'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'ULL';\n        } else {\n          // UL but no L\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      } else {\n        // U but no L\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      }\n    } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'LL';\n        } else {\n          // First L but no second L\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n    }\n  }\n\n  // Lua hexadecimals have an optional fraction part and an optional binary\n  // exoponent part. These are not included in JavaScript so we will compute\n  // all three parts separately and then sum them up at the end of the function\n  // with the following algorithm.\n  //\n  //     Digit := toDec(digit)\n  //     Fraction := toDec(fraction) / 16 ^ fractionCount\n  //     BinaryExp := 2 ^ binaryExp\n  //     Number := ( Digit + Fraction ) * BinaryExp\n\n  function readHexLiteral() {\n    var fraction = 0 // defaults to 0 as it gets summed\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\n      , binarySign = 1 // positive\n      , digit, fractionStart, exponentStart, digitStart;\n\n    digitStart = index += 2; // Skip 0x part\n\n    // A minimum of one hex digit is required.\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n    while (isHexDigit(input.charCodeAt(index))) ++index;\n    // Convert the hexadecimal digit to base 10.\n    digit = parseInt(input.slice(digitStart, index), 16);\n\n    // Fraction part is optional.\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      fractionStart = ++index;\n\n      while (isHexDigit(input.charCodeAt(index))) ++index;\n      fraction = input.slice(fractionStart, index);\n\n      // Empty fraction parts should default to 0, others should be converted\n      // 0.x form so we can use summation at the end.\n      fraction = (fractionStart === index) ? 0\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n    }\n\n    // Binary exponents are optional\n    var foundBinaryExponent = false;\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n      foundBinaryExponent = true;\n      ++index;\n\n      // Sign part is optional and defaults to 1 (positive).\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\n\n      exponentStart = index;\n\n      // The binary exponent sign requires a decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n      binaryExponent = input.slice(exponentStart, index);\n\n      // Calculate the binary exponent of the number.\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\n    }\n\n    return {\n      value: (digit + fraction) * binaryExponent,\n      hasFractionPart: foundFraction || foundBinaryExponent\n    };\n  }\n\n  // Decimal numbers are exactly the same in Lua and in JavaScript, because of\n  // this we check where the token ends and then parse it with native\n  // functions.\n\n  function readDecLiteral() {\n    while (isDecDigit(input.charCodeAt(index))) ++index;\n    // Fraction part is optional\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      ++index;\n      // Fraction part defaults to 0\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    // Exponent part is optional.\n    var foundExponent = false;\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n      foundExponent = true;\n      ++index;\n      // Sign part is optional.\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;\n      // An exponent is required to contain at least one decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    return {\n      value: parseFloat(input.slice(tokenStart, index)),\n      hasFractionPart: foundFraction || foundExponent\n    };\n  }\n\n  function readUnicodeEscapeSequence() {\n    var sequenceStart = index++;\n\n    if (input.charAt(index++) !== '{')\n      raise(null, errors.braceExpected, '{', '\\\\' + input.slice(sequenceStart, index));\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n\n    while (input.charCodeAt(index) === 0x30) ++index;\n    var escStart = index;\n\n    while (isHexDigit(input.charCodeAt(index))) {\n      ++index;\n      if (index - escStart > 6)\n        raise(null, errors.tooLargeCodepoint, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var b = input.charAt(index++);\n    if (b !== '}') {\n      if ((b === '\"') || (b === \"'\"))\n        raise(null, errors.braceExpected, '}', '\\\\' + input.slice(sequenceStart, index--));\n      else\n        raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);\n    var frag = '\\\\' + input.slice(sequenceStart, index);\n\n    if (codepoint > 0x10ffff) {\n      raise(null, errors.tooLargeCodepoint, frag);\n    }\n\n    return encodingMode.encodeUTF8(codepoint, frag);\n  }\n\n  // Translate escape sequences to the actual characters.\n  function readEscapeSequence() {\n    var sequenceStart = index;\n    switch (input.charAt(index)) {\n      // Lua allow the following escape sequences.\n      case 'a': ++index; return '\\x07';\n      case 'n': ++index; return '\\n';\n      case 'r': ++index; return '\\r';\n      case 't': ++index; return '\\t';\n      case 'v': ++index; return '\\x0b';\n      case 'b': ++index; return '\\b';\n      case 'f': ++index; return '\\f';\n\n      // Backslash at the end of the line. We treat all line endings as equivalent,\n      // and as representing the [LF] character (code 10). Lua 5.1 through 5.3\n      // have been verified to behave the same way.\n      case '\\r':\n      case '\\n':\n        consumeEOL();\n        return '\\n';\n\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n        // \\ddd, where ddd is a sequence of up to three decimal digits.\n        while (isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3) ++index;\n\n        var frag = input.slice(sequenceStart, index);\n        var ddd = parseInt(frag, 10);\n        if (ddd > 255) {\n          raise(null, errors.decimalEscapeTooLarge, '\\\\' + ddd);\n        }\n        return encodingMode.encodeByte(ddd, '\\\\' + frag);\n\n      case 'z':\n        if (features.skipWhitespaceEscape) {\n          ++index;\n          skipWhiteSpace();\n          return '';\n        }\n        break;\n\n      case 'x':\n        if (features.hexEscapes) {\n          // \\xXX, where XX is a sequence of exactly two hexadecimal digits\n          if (isHexDigit(input.charCodeAt(index + 1)) &&\n              isHexDigit(input.charCodeAt(index + 2))) {\n            index += 3;\n            return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\\\' + input.slice(sequenceStart, index));\n          }\n          raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index + 2));\n        }\n        break;\n\n      case 'u':\n        if (features.unicodeEscapes)\n          return readUnicodeEscapeSequence();\n        break;\n\n      case '\\\\': case '\"': case \"'\":\n        return input.charAt(index++);\n    }\n\n    if (features.strictEscapes)\n      raise(null, errors.invalidEscape, '\\\\' + input.slice(sequenceStart, index + 1));\n    return input.charAt(index++);\n  }\n\n  // Comments begin with -- after which it will be decided if they are\n  // multiline comments or not.\n  //\n  // The multiline functionality works the exact same way as with string\n  // literals so we reuse the functionality.\n\n  function scanComment() {\n    tokenStart = index;\n    index += 2; // --\n\n    var character = input.charAt(index)\n      , content = ''\n      , isLong = false\n      , commentStart = index\n      , lineStartComment = lineStart\n      , lineComment = line;\n\n    if ('[' === character) {\n      content = readLongString(true);\n      // This wasn't a multiline comment after all.\n      if (false === content) content = character;\n      else isLong = true;\n    }\n    // Scan until next line as long as it's not a multiline comment.\n    if (!isLong) {\n      while (index < length) {\n        if (isLineTerminator(input.charCodeAt(index))) break;\n        ++index;\n      }\n      if (options.comments) content = input.slice(commentStart, index);\n    }\n\n    if (options.comments) {\n      var node = ast.comment(content, input.slice(tokenStart, index));\n\n      // `Marker`s depend on tokens available in the parser and as comments are\n      // intercepted in the lexer all location data is set manually.\n      if (options.locations) {\n        node.loc = {\n            start: { line: lineComment, column: tokenStart - lineStartComment }\n          , end: { line: line, column: index - lineStart }\n        };\n      }\n      if (options.ranges) {\n        node.range = [tokenStart, index];\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      comments.push(node);\n    }\n  }\n\n  // Read a multiline string by calculating the depth of `=` characters and\n  // then appending until an equal depth is found.\n\n  function readLongString(isComment) {\n    var level = 0\n      , content = ''\n      , terminator = false\n      , character, stringStart, firstLine = line;\n\n    ++index; // [\n\n    // Calculate the depth of the comment.\n    while ('=' === input.charAt(index + level)) ++level;\n    // Exit, this is not a long string afterall.\n    if ('[' !== input.charAt(index + level)) return false;\n\n    index += level + 1;\n\n    // If the first character is a newline, ignore it and begin on next line.\n    if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n    stringStart = index;\n    while (index < length) {\n      // To keep track of line numbers run the `consumeEOL()` which increments\n      // its counter.\n      while (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n      character = input.charAt(index++);\n\n      // Once the delimiter is found, iterate through the depth count and see\n      // if it matches.\n      if (']' === character) {\n        terminator = true;\n        for (var i = 0; i < level; ++i) {\n          if ('=' !== input.charAt(index + i)) terminator = false;\n        }\n        if (']' !== input.charAt(index + level)) terminator = false;\n      }\n\n      // We reached the end of the multiline string. Get out now.\n      if (terminator) {\n        content += input.slice(stringStart, index - 1);\n        index += level + 1;\n        return content;\n      }\n    }\n\n    raise(null, isComment ?\n                errors.unfinishedLongComment :\n                errors.unfinishedLongString,\n          firstLine, '<eof>');\n  }\n\n  // ## Lex functions and helpers.\n\n  // Read the next token.\n  //\n  // This is actually done by setting the current token to the lookahead and\n  // reading in the new lookahead token.\n\n  function next() {\n    previousToken = token;\n    token = lookahead;\n    lookahead = lex();\n  }\n\n  // Consume a token if its value matches. Once consumed or not, return the\n  // success of the operation.\n\n  function consume(value) {\n    if (value === token.value) {\n      next();\n      return true;\n    }\n    return false;\n  }\n\n  // Expect the next token value to match. If not, throw an exception.\n\n  function expect(value) {\n    if (value === token.value) next();\n    else raise(token, errors.expected, value, tokenValue(token));\n  }\n\n  // ### Validation functions\n\n  function isWhiteSpace(charCode) {\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n  }\n\n  function isLineTerminator(charCode) {\n    return 10 === charCode || 13 === charCode;\n  }\n\n  function isDecDigit(charCode) {\n    return charCode >= 48 && charCode <= 57;\n  }\n\n  function isHexDigit(charCode) {\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\n  }\n\n  // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards\n  // identifiers cannot use 'locale-dependent' letters (i.e. dependent on the C locale).\n  // On the other hand, LuaJIT allows arbitrary octets â‰¥ 128 in identifiers.\n\n  function isIdentifierStart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode)\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  function isIdentifierPart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57))\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)\n  //\n  // `true`, `false` and `nil` will not be considered keywords, but literals.\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n      case 3:\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n      case 4:\n        if ('else' === id || 'then' === id)\n          return true;\n        if (features.labels && !features.contextualGoto)\n          return ('goto' === id);\n        return false;\n      case 5:\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n      case 6:\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\n      case 8:\n        return 'function' === id;\n    }\n    return false;\n  }\n\n  function isUnary(token) {\n    if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n    if (Keyword === token.type) return 'not' === token.value;\n    return false;\n  }\n\n  // Check if the token syntactically closes a block.\n\n  function isBlockFollow(token) {\n    if (EOF === token.type) return true;\n    if (Keyword !== token.type) return false;\n    switch (token.value) {\n      case 'else': case 'elseif':\n      case 'end': case 'until':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // Scope\n  // -----\n\n  // Store each block scope as a an array of identifier names. Each scope is\n  // stored in an FILO-array.\n  var scopes\n    // The current scope index\n    , scopeDepth\n    // A list of all global identifier nodes.\n    , globals;\n\n  // Create a new scope inheriting all declarations from the previous scope.\n  function createScope() {\n    var scope = scopes[scopeDepth++].slice();\n    scopes.push(scope);\n    if (options.onCreateScope) options.onCreateScope();\n  }\n\n  // Exit and remove the current scope.\n  function destroyScope() {\n    var scope = scopes.pop();\n    --scopeDepth;\n    if (options.onDestroyScope) options.onDestroyScope();\n  }\n\n  // Add identifier name to the current scope if it doesnt already exist.\n  function scopeIdentifierName(name) {\n    if (options.onLocalDeclaration) options.onLocalDeclaration(name);\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n    scopes[scopeDepth].push(name);\n  }\n\n  // Add identifier to the current scope\n  function scopeIdentifier(node) {\n    scopeIdentifierName(node.name);\n    attachScope(node, true);\n  }\n\n  // Attach scope information to node. If the node is global, store it in the\n  // globals array so we can return the information to the user.\n  function attachScope(node, isLocal) {\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\n      globals.push(node);\n\n    node.isLocal = isLocal;\n  }\n\n  // Is the identifier name available in this scope.\n  function scopeHasName(name) {\n    return (-1 !== indexOf(scopes[scopeDepth], name));\n  }\n\n  // Location tracking\n  // -----------------\n  //\n  // Locations are stored in FILO-array as a `Marker` object consisting of both\n  // `loc` and `range` data. Once a `Marker` is popped off the list an end\n  // location is added and the data is attached to a syntax node.\n\n  var locations = []\n    , trackLocations;\n\n  function createLocationMarker() {\n    return new Marker(token);\n  }\n\n  function Marker(token) {\n    if (options.locations) {\n      this.loc = {\n          start: {\n            line: token.line\n          , column: token.range[0] - token.lineStart\n        }\n        , end: {\n            line: 0\n          , column: 0\n        }\n      };\n    }\n    if (options.ranges) this.range = [token.range[0], 0];\n  }\n\n  // Complete the location data stored in the `Marker` by adding the location\n  // of the *previous token* as an end location.\n  Marker.prototype.complete = function() {\n    if (options.locations) {\n      this.loc.end.line = previousToken.lastLine || previousToken.line;\n      this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);\n    }\n    if (options.ranges) {\n      this.range[1] = previousToken.range[1];\n    }\n  };\n\n  Marker.prototype.bless = function (node) {\n    if (this.loc) {\n      var loc = this.loc;\n      node.loc = {\n        start: {\n          line: loc.start.line,\n          column: loc.start.column\n        },\n        end: {\n          line: loc.end.line,\n          column: loc.end.column\n        }\n      };\n    }\n    if (this.range) {\n      node.range = [\n        this.range[0],\n        this.range[1]\n      ];\n    }\n  };\n\n  // Create a new `Marker` and add it to the FILO-array.\n  function markLocation() {\n    if (trackLocations) locations.push(createLocationMarker());\n  }\n\n  // Push an arbitrary `Marker` object onto the FILO-array.\n  function pushLocation(marker) {\n    if (trackLocations) locations.push(marker);\n  }\n\n  // Control flow tracking\n  // ---------------------\n  // A context object that validates loop breaks and `goto`-based control flow.\n\n  function FullFlowContext() {\n    this.scopes = [];\n    this.pendingGotos = [];\n  }\n\n  FullFlowContext.prototype.isInLoop = function () {\n    var i = this.scopes.length;\n    while (i --> 0) {\n      if (this.scopes[i].isLoop)\n        return true;\n    }\n    return false;\n  };\n\n  FullFlowContext.prototype.pushScope = function (isLoop) {\n    var scope = {\n      labels: {},\n      locals: [],\n      deferredGotos: [],\n      isLoop: !!isLoop\n    };\n    this.scopes.push(scope);\n  };\n\n  FullFlowContext.prototype.popScope = function () {\n    for (var i = 0; i < this.pendingGotos.length; ++i) {\n      var theGoto = this.pendingGotos[i];\n      if (theGoto.maxDepth >= this.scopes.length)\n        if (--theGoto.maxDepth <= 0)\n          raise(theGoto.token, errors.labelNotVisible, theGoto.target);\n    }\n\n    this.scopes.pop();\n  };\n\n  FullFlowContext.prototype.addGoto = function (target, token) {\n    var localCounts = [];\n\n    for (var i = 0; i < this.scopes.length; ++i) {\n      var scope = this.scopes[i];\n      localCounts.push(scope.locals.length);\n      if (Object.prototype.hasOwnProperty.call(scope.labels, target))\n        return;\n    }\n\n    this.pendingGotos.push({\n      maxDepth: this.scopes.length,\n      target: target,\n      token: token,\n      localCounts: localCounts\n    });\n  };\n\n  FullFlowContext.prototype.addLabel = function (name, token) {\n    var scope = this.currentScope();\n\n    if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {\n      raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);\n    } else {\n      var newGotos = [];\n\n      for (var i = 0; i < this.pendingGotos.length; ++i) {\n        var theGoto = this.pendingGotos[i];\n\n        if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {\n          if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {\n            scope.deferredGotos.push(theGoto);\n          }\n          continue;\n        }\n\n        newGotos.push(theGoto);\n      }\n\n      this.pendingGotos = newGotos;\n    }\n\n    scope.labels[name] = {\n      localCount: scope.locals.length,\n      line: token.line\n    };\n  };\n\n  FullFlowContext.prototype.addLocal = function (name, token) {\n    this.currentScope().locals.push({\n      name: name,\n      token: token\n    });\n  };\n\n  FullFlowContext.prototype.currentScope = function () {\n    return this.scopes[this.scopes.length - 1];\n  };\n\n  FullFlowContext.prototype.raiseDeferredErrors = function () {\n    var scope = this.currentScope();\n    var bads = scope.deferredGotos;\n    for (var i = 0; i < bads.length; ++i) {\n      var theGoto = bads[i];\n      raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);\n    }\n    // Would be dead code currently, but may be useful later\n    // if (bads.length)\n    //   scope.deferredGotos = [];\n  };\n\n  // Simplified context that only checks the validity of loop breaks.\n\n  function LoopFlowContext() {\n    this.level = 0;\n    this.loopLevels = [];\n  }\n\n  LoopFlowContext.prototype.isInLoop = function () {\n    return !!this.loopLevels.length;\n  };\n\n  LoopFlowContext.prototype.pushScope = function (isLoop) {\n    ++this.level;\n    if (isLoop)\n      this.loopLevels.push(this.level);\n  };\n\n  LoopFlowContext.prototype.popScope = function () {\n    var levels = this.loopLevels;\n    var levlen = levels.length;\n    if (levlen) {\n      if (levels[levlen - 1] === this.level)\n        levels.pop();\n    }\n    --this.level;\n  };\n\n  LoopFlowContext.prototype.addGoto =\n  LoopFlowContext.prototype.addLabel =\n  /* istanbul ignore next */\n  function () { throw new Error('This should never happen'); };\n\n  LoopFlowContext.prototype.addLocal =\n  LoopFlowContext.prototype.raiseDeferredErrors =\n  function () {};\n\n  function makeFlowContext() {\n    return features.labels ? new FullFlowContext() : new LoopFlowContext();\n  }\n\n  // Parse functions\n  // ---------------\n\n  // Chunk is the main program object. Syntactically it's the same as a block.\n  //\n  //     chunk ::= block\n\n  function parseChunk() {\n    next();\n    markLocation();\n    if (options.scope) createScope();\n    var flowContext = makeFlowContext();\n    flowContext.allowVararg = true;\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    if (EOF !== token.type) unexpected(token);\n    // If the body is empty no previousToken exists when finishNode runs.\n    if (trackLocations && !body.length) previousToken = token;\n    return finishNode(ast.chunk(body));\n  }\n\n  // A block contains a list of statements with an optional return statement\n  // as its last statement.\n  //\n  //     block ::= {stat} [retstat]\n\n  function parseBlock(flowContext) {\n    var block = []\n      , statement;\n\n    while (!isBlockFollow(token)) {\n      // Return has to be the last statement in a block.\n      // Likewise 'break' in Lua older than 5.2\n      if ('return' === token.value || (!features.relaxedBreak && 'break' === token.value)) {\n        block.push(parseStatement(flowContext));\n        break;\n      }\n      statement = parseStatement(flowContext);\n      consume(';');\n      // Statements are only added if they are returned, this allows us to\n      // ignore some statements, such as EmptyStatement.\n      if (statement) block.push(statement);\n    }\n\n    // Doesn't really need an ast node\n    return block;\n  }\n\n  // There are two types of statements, simple and compound.\n  //\n  //     statement ::= break | goto | do | while | repeat | return\n  //          | if | for | function | local | label | assignment\n  //          | functioncall | ';'\n\n  function parseStatement(flowContext) {\n    markLocation();\n\n    if (Punctuator === token.type) {\n      if (consume('::')) return parseLabelStatement(flowContext);\n    }\n\n    // When a `;` is encounted, simply eat it without storing it.\n    if (features.emptyStatement) {\n      if (consume(';')) {\n        if (trackLocations) locations.pop();\n        return;\n      }\n    }\n\n    flowContext.raiseDeferredErrors();\n\n    if (Keyword === token.type) {\n      switch (token.value) {\n        case 'local':    next(); return parseLocalStatement(flowContext);\n        case 'if':       next(); return parseIfStatement(flowContext);\n        case 'return':   next(); return parseReturnStatement(flowContext);\n        case 'function': next();\n          var name = parseFunctionName();\n          return parseFunctionDeclaration(name);\n        case 'while':    next(); return parseWhileStatement(flowContext);\n        case 'for':      next(); return parseForStatement(flowContext);\n        case 'repeat':   next(); return parseRepeatStatement(flowContext);\n        case 'break':    next();\n          if (!flowContext.isInLoop())\n            raise(token, errors.noLoopToBreak, token.value);\n          return parseBreakStatement();\n        case 'do':       next(); return parseDoStatement(flowContext);\n        case 'goto':     next(); return parseGotoStatement(flowContext);\n      }\n    }\n\n    if (features.contextualGoto &&\n        token.type === Identifier && token.value === 'goto' &&\n        lookahead.type === Identifier && lookahead.value !== 'goto') {\n      next(); return parseGotoStatement(flowContext);\n    }\n\n    // Assignments memorizes the location and pushes it manually for wrapper nodes.\n    if (trackLocations) locations.pop();\n\n    return parseAssignmentOrCallStatement(flowContext);\n  }\n\n  // ## Statements\n\n  //     label ::= '::' Name '::'\n\n  function parseLabelStatement(flowContext) {\n    var nameToken = token\n      , label = parseIdentifier();\n\n    if (options.scope) {\n      scopeIdentifierName('::' + nameToken.value + '::');\n      attachScope(label, true);\n    }\n\n    expect('::');\n\n    flowContext.addLabel(nameToken.value, nameToken);\n    return finishNode(ast.labelStatement(label));\n  }\n\n  //     break ::= 'break'\n\n  function parseBreakStatement() {\n    return finishNode(ast.breakStatement());\n  }\n\n  //     goto ::= 'goto' Name\n\n  function parseGotoStatement(flowContext) {\n    var name = token.value\n      , gotoToken = previousToken\n      , label = parseIdentifier();\n\n    flowContext.addGoto(name, gotoToken);\n    return finishNode(ast.gotoStatement(label));\n  }\n\n  //     do ::= 'do' block 'end'\n\n  function parseDoStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.doStatement(body));\n  }\n\n  //     while ::= 'while' exp 'do' block 'end'\n\n  function parseWhileStatement(flowContext) {\n    var condition = parseExpectedExpression(flowContext);\n    expect('do');\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.whileStatement(condition, body));\n  }\n\n  //     repeat ::= 'repeat' block 'until' exp\n\n  function parseRepeatStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    expect('until');\n    flowContext.raiseDeferredErrors();\n    var condition = parseExpectedExpression(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    return finishNode(ast.repeatStatement(condition, body));\n  }\n\n  //     retstat ::= 'return' [exp {',' exp}] [';']\n\n  function parseReturnStatement(flowContext) {\n    var expressions = [];\n\n    if ('end' !== token.value) {\n      var expression = parseExpression(flowContext);\n      if (null != expression) expressions.push(expression);\n      while (consume(',')) {\n        expression = parseExpectedExpression(flowContext);\n        expressions.push(expression);\n      }\n      consume(';'); // grammar tells us ; is optional here.\n    }\n    return finishNode(ast.returnStatement(expressions));\n  }\n\n  //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'\n  //     elif ::= 'elseif' exp 'then' block\n\n  function parseIfStatement(flowContext) {\n    var clauses = []\n      , condition\n      , body\n      , marker;\n\n    // IfClauses begin at the same location as the parent IfStatement.\n    // It ends at the start of `end`, `else`, or `elseif`.\n    if (trackLocations) {\n      marker = locations[locations.length - 1];\n      locations.push(marker);\n    }\n    condition = parseExpectedExpression(flowContext);\n    expect('then');\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    clauses.push(finishNode(ast.ifClause(condition, body)));\n\n    if (trackLocations) marker = createLocationMarker();\n    while (consume('elseif')) {\n      pushLocation(marker);\n      condition = parseExpectedExpression(flowContext);\n      expect('then');\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n    }\n\n    if (consume('else')) {\n      // Include the `else` in the location of ElseClause.\n      if (trackLocations) {\n        marker = new Marker(previousToken);\n        locations.push(marker);\n      }\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseClause(body)));\n    }\n\n    expect('end');\n    return finishNode(ast.ifStatement(clauses));\n  }\n\n  // There are two types of for statements, generic and numeric.\n  //\n  //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'\n  //     for ::= namelist 'in' explist 'do' block 'end'\n  //     namelist ::= Name {',' Name}\n  //     explist ::= exp {',' exp}\n\n  function parseForStatement(flowContext) {\n    var variable = parseIdentifier()\n      , body;\n\n    // The start-identifier is local.\n\n    if (options.scope) {\n      createScope();\n      scopeIdentifier(variable);\n    }\n\n    // If the first expression is followed by a `=` punctuator, this is a\n    // Numeric For Statement.\n    if (consume('=')) {\n      // Start expression\n      var start = parseExpectedExpression(flowContext);\n      expect(',');\n      // End expression\n      var end = parseExpectedExpression(flowContext);\n      // Optional step expression\n      var step = consume(',') ? parseExpectedExpression(flowContext) : null;\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n    }\n    // If not, it's a Generic For Statement\n    else {\n      // The namelist can contain one or more identifiers.\n      var variables = [variable];\n      while (consume(',')) {\n        variable = parseIdentifier();\n        // Each variable in the namelist is locally scoped.\n        if (options.scope) scopeIdentifier(variable);\n        variables.push(variable);\n      }\n      expect('in');\n      var iterators = [];\n\n      // One or more expressions in the explist.\n      do {\n        var expression = parseExpectedExpression(flowContext);\n        iterators.push(expression);\n      } while (consume(','));\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\n    }\n  }\n\n  // Local statements can either be variable assignments or function\n  // definitions. If a function definition is found, it will be delegated to\n  // `parseFunctionDeclaration()` with the isLocal flag.\n  //\n  // This AST structure might change into a local assignment with a function\n  // child.\n  //\n  //     local ::= 'local' 'function' Name funcdecl\n  //        | 'local' Name {',' Name} ['=' exp {',' exp}]\n\n  function parseLocalStatement(flowContext) {\n    var name\n      , declToken = previousToken;\n\n    if (Identifier === token.type) {\n      var variables = []\n        , init = [];\n\n      do {\n        name = parseIdentifier();\n\n        variables.push(name);\n        flowContext.addLocal(name.name, declToken);\n      } while (consume(','));\n\n      if (consume('=')) {\n        do {\n          var expression = parseExpectedExpression(flowContext);\n          init.push(expression);\n        } while (consume(','));\n      }\n\n      // Declarations doesn't exist before the statement has been evaluated.\n      // Therefore assignments can't use their declarator. And the identifiers\n      // shouldn't be added to the scope until the statement is complete.\n      if (options.scope) {\n        for (var i = 0, l = variables.length; i < l; ++i) {\n          scopeIdentifier(variables[i]);\n        }\n      }\n\n      return finishNode(ast.localStatement(variables, init));\n    }\n    if (consume('function')) {\n      name = parseIdentifier();\n      flowContext.addLocal(name.name, declToken);\n\n      if (options.scope) {\n        scopeIdentifier(name);\n        createScope();\n      }\n\n      // MemberExpressions are not allowed in local function statements.\n      return parseFunctionDeclaration(name, true);\n    } else {\n      raiseUnexpectedToken('<name>', token);\n    }\n  }\n\n  //     assignment ::= varlist '=' explist\n  //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name\n  //     varlist ::= var {',' var}\n  //     explist ::= exp {',' exp}\n  //\n  //     call ::= callexp\n  //     callexp ::= prefixexp args | prefixexp ':' Name args\n\n  function parseAssignmentOrCallStatement(flowContext) {\n    // Keep a reference to the previous token for better error messages in case\n    // of invalid statement\n    var previous = token\n      , marker, startMarker;\n    var lvalue, base, name;\n\n    var targets = [];\n\n    if (trackLocations) startMarker = createLocationMarker();\n\n    do {\n      if (trackLocations) marker = createLocationMarker();\n\n      if (Identifier === token.type) {\n        name = token.value;\n        base = parseIdentifier();\n        // Set the parent scope.\n        if (options.scope) attachScope(base, scopeHasName(name));\n        lvalue = true;\n      } else if ('(' === token.value) {\n        next();\n        base = parseExpectedExpression(flowContext);\n        expect(')');\n        lvalue = false;\n      } else {\n        return unexpected(token);\n      }\n\n      both: for (;;) {\n        var newBase;\n\n        switch (StringLiteral === token.type ? '\"' : token.value) {\n        case '.':\n        case '[':\n          lvalue = true;\n          break;\n        case ':':\n        case '(':\n        case '{':\n        case '\"':\n          lvalue = null;\n          break;\n        default:\n          break both;\n        }\n\n        base = parsePrefixExpressionPart(base, marker, flowContext);\n      }\n\n      targets.push(base);\n\n      if (',' !== token.value)\n        break;\n\n      if (!lvalue) {\n        return unexpected(token);\n      }\n\n      next();\n    } while (true);\n\n    if (targets.length === 1 && lvalue === null) {\n      pushLocation(marker);\n      return finishNode(ast.callStatement(targets[0]));\n    } else if (!lvalue) {\n      return unexpected(token);\n    }\n\n    expect('=');\n\n    var values = [];\n\n    do {\n      values.push(parseExpectedExpression(flowContext));\n    } while (consume(','));\n\n    pushLocation(startMarker);\n    return finishNode(ast.assignmentStatement(targets, values));\n  }\n\n  // ### Non-statements\n\n  //     Identifier ::= Name\n\n  function parseIdentifier() {\n    markLocation();\n    var identifier = token.value;\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n    next();\n    return finishNode(ast.identifier(identifier));\n  }\n\n  // Parse the functions parameters and body block. The name should already\n  // have been parsed and passed to this declaration function. By separating\n  // this we allow for anonymous functions in expressions.\n  //\n  // For local functions there's a boolean parameter which needs to be set\n  // when parsing the declaration.\n  //\n  //     funcdecl ::= '(' [parlist] ')' block 'end'\n  //     parlist ::= Name {',' Name} | [',' '...'] | '...'\n\n  function parseFunctionDeclaration(name, isLocal) {\n    var flowContext = makeFlowContext();\n    flowContext.pushScope();\n\n    var parameters = [];\n    expect('(');\n\n    // The declaration has arguments\n    if (!consume(')')) {\n      // Arguments are a comma separated list of identifiers, optionally ending\n      // with a vararg.\n      while (true) {\n        if (Identifier === token.type) {\n          var parameter = parseIdentifier();\n          // Function parameters are local.\n          if (options.scope) scopeIdentifier(parameter);\n\n          parameters.push(parameter);\n\n          if (consume(',')) continue;\n        }\n        // No arguments are allowed after a vararg.\n        else if (VarargLiteral === token.type) {\n          flowContext.allowVararg = true;\n          parameters.push(parsePrimaryExpression(flowContext));\n        } else {\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\n        }\n        expect(')');\n        break;\n      }\n    }\n\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    expect('end');\n    if (options.scope) destroyScope();\n\n    isLocal = isLocal || false;\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n  }\n\n  // Parse the function name as identifiers and member expressions.\n  //\n  //     Name {'.' Name} [':' Name]\n\n  function parseFunctionName() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    base = parseIdentifier();\n\n    if (options.scope) {\n      attachScope(base, scopeHasName(base.name));\n      createScope();\n    }\n\n    while (consume('.')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, '.', name));\n    }\n\n    if (consume(':')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, ':', name));\n      if (options.scope) scopeIdentifierName('self');\n    }\n\n    return base;\n  }\n\n  //     tableconstructor ::= '{' [fieldlist] '}'\n  //     fieldlist ::= field {fieldsep field} fieldsep\n  //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp\n  //\n  //     fieldsep ::= ',' | ';'\n\n  function parseTableConstructor(flowContext) {\n    var fields = []\n      , key, value;\n\n    while (true) {\n      markLocation();\n      if (Punctuator === token.type && consume('[')) {\n        key = parseExpectedExpression(flowContext);\n        expect(']');\n        expect('=');\n        value = parseExpectedExpression(flowContext);\n        fields.push(finishNode(ast.tableKey(key, value)));\n      } else if (Identifier === token.type) {\n        if ('=' === lookahead.value) {\n          key = parseIdentifier();\n          next();\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableKeyString(key, value)));\n        } else {\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n      } else {\n        if (null == (value = parseExpression(flowContext))) {\n          locations.pop();\n          break;\n        }\n        fields.push(finishNode(ast.tableValue(value)));\n      }\n      if (',;'.indexOf(token.value) >= 0) {\n        next();\n        continue;\n      }\n      break;\n    }\n    expect('}');\n    return finishNode(ast.tableConstructorExpression(fields));\n  }\n\n  // Expression parser\n  // -----------------\n  //\n  // Expressions are evaluated and always return a value. If nothing is\n  // matched null will be returned.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n  //\n  //     primary ::= nil | false | true | Number | String | '...'\n  //          | functiondef | tableconstructor\n  //\n  //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'\n  //          | '.' Name | ':' Name args | args }\n  //\n\n  function parseExpression(flowContext) {\n    var expression = parseSubExpression(0, flowContext);\n    return expression;\n  }\n\n  // Parse an expression expecting it to be valid.\n\n  function parseExpectedExpression(flowContext) {\n    var expression = parseExpression(flowContext);\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\n    else return expression;\n  }\n\n\n  // Return the precedence priority of the operator.\n  //\n  // As unary `-` can't be distinguished from binary `-`, unary precedence\n  // isn't described in this table but in `parseSubExpression()` itself.\n  //\n  // As this function gets hit on every expression it's been optimized due to\n  // the expensive CompareICStub which took ~8% of the parse time.\n\n  function binaryPrecedence(operator) {\n    var charCode = operator.charCodeAt(0)\n      , length = operator.length;\n\n    if (1 === length) {\n      switch (charCode) {\n        case 94: return 12; // ^\n        case 42: case 47: case 37: return 10; // * / %\n        case 43: case 45: return 9; // + -\n        case 38: return 6; // &\n        case 126: return 5; // ~\n        case 124: return 4; // |\n        case 60: case 62: return 3; // < >\n      }\n    } else if (2 === length) {\n      switch (charCode) {\n        case 47: return 10; // //\n        case 46: return 8; // ..\n        case 60: case 62:\n            if('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3; // <= >=\n        case 61: case 126: return 3; // == ~=\n        case 111: return 1; // or\n      }\n    } else if (97 === charCode && 'and' === operator) return 2;\n    return 0;\n  }\n\n  // Implement an operator-precedence parser to handle binary operator\n  // precedence.\n  //\n  // We use this algorithm because it's compact, it's fast and Lua core uses\n  // the same so we can be sure our expressions are parsed in the same manner\n  // without excessive amounts of tests.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n\n  function parseSubExpression(minPrecedence, flowContext) {\n    var operator = token.value\n    // The left-hand side in binary operations.\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // UnaryExpression\n    if (isUnary(token)) {\n      markLocation();\n      next();\n      var argument = parseSubExpression(10, flowContext);\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\n      expression = finishNode(ast.unaryExpression(operator, argument));\n    }\n    if (null == expression) {\n      // PrimaryExpression\n      expression = parsePrimaryExpression(flowContext);\n\n      // PrefixExpression\n      if (null == expression) {\n        expression = parsePrefixExpression(flowContext);\n      }\n    }\n    // This is not a valid left hand expression.\n    if (null == expression) return null;\n\n    var precedence;\n    while (true) {\n      operator = token.value;\n\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\n        binaryPrecedence(operator) : 0;\n\n      if (precedence === 0 || precedence <= minPrecedence) break;\n      // Right-hand precedence operators\n      if ('^' === operator || '..' === operator) --precedence;\n      next();\n      var right = parseSubExpression(precedence, flowContext);\n      if (null == right) raiseUnexpectedToken('<expression>', token);\n      // Push in the marker created before the loop to wrap its entirety.\n      if (trackLocations) locations.push(marker);\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\n\n    }\n    return expression;\n  }\n\n  //     prefixexp ::= prefix {suffix}\n  //     prefix ::= Name | '(' exp ')'\n  //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args\n  //\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parsePrefixExpressionPart(base, marker, flowContext) {\n    var expression, identifier;\n\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '[':\n          pushLocation(marker);\n          next();\n          expression = parseExpectedExpression(flowContext);\n          expect(']');\n          return finishNode(ast.indexExpression(base, expression));\n        case '.':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          return finishNode(ast.memberExpression(base, '.', identifier));\n        case ':':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          base = finishNode(ast.memberExpression(base, ':', identifier));\n          // Once a : is found, this has to be a CallExpression, otherwise\n          // throw an error.\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n        case '(': case '{': // args\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n      }\n    } else if (StringLiteral === token.type) {\n      pushLocation(marker);\n      return parseCallExpression(base, flowContext);\n    }\n\n    return null;\n  }\n\n  function parsePrefixExpression(flowContext) {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // The prefix\n    if (Identifier === token.type) {\n      name = token.value;\n      base = parseIdentifier();\n      // Set the parent scope.\n      if (options.scope) attachScope(base, scopeHasName(name));\n    } else if (consume('(')) {\n      base = parseExpectedExpression(flowContext);\n      expect(')');\n    } else {\n      return null;\n    }\n\n    // The suffix\n    for (;;) {\n      var newBase = parsePrefixExpressionPart(base, marker, flowContext);\n      if (newBase === null)\n        break;\n      base = newBase;\n    }\n\n    return base;\n  }\n\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parseCallExpression(base, flowContext) {\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '(':\n          if (!features.emptyStatement) {\n            if (token.line !== previousToken.line)\n              raise(null, errors.ambiguousSyntax, token.value);\n          }\n          next();\n\n          // List of expressions\n          var expressions = [];\n          var expression = parseExpression(flowContext);\n          if (null != expression) expressions.push(expression);\n          while (consume(',')) {\n            expression = parseExpectedExpression(flowContext);\n            expressions.push(expression);\n          }\n\n          expect(')');\n          return finishNode(ast.callExpression(base, expressions));\n\n        case '{':\n          markLocation();\n          next();\n          var table = parseTableConstructor(flowContext);\n          return finishNode(ast.tableCallExpression(base, table));\n      }\n    } else if (StringLiteral === token.type) {\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));\n    }\n\n    raiseUnexpectedToken('function arguments', token);\n  }\n\n  //     primary ::= String | Numeric | nil | true | false\n  //          | functiondef | tableconstructor | '...'\n\n  function parsePrimaryExpression(flowContext) {\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\n      , value = token.value\n      , type = token.type\n      , marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    if (type === VarargLiteral && !flowContext.allowVararg) {\n      raise(token, errors.cannotUseVararg, token.value);\n    }\n\n    if (type & literals) {\n      pushLocation(marker);\n      var raw = input.slice(token.range[0], token.range[1]);\n      next();\n      return finishNode(ast.literal(type, value, raw));\n    } else if (Keyword === type && 'function' === value) {\n      pushLocation(marker);\n      next();\n      if (options.scope) createScope();\n      return parseFunctionDeclaration(null);\n    } else if (consume('{')) {\n      pushLocation(marker);\n      return parseTableConstructor(flowContext);\n    }\n  }\n\n  // Parser\n  // ------\n\n  // Export the main parser.\n  //\n  //   - `wait` Hold parsing until end() is called. Defaults to false\n  //   - `comments` Store comments. Defaults to true.\n  //   - `scope` Track identifier scope. Defaults to false.\n  //   - `locations` Store location information. Defaults to false.\n  //   - `ranges` Store the start and end character locations. Defaults to\n  //     false.\n  //   - `onCreateNode` Callback which will be invoked when a syntax node is\n  //     created.\n  //   - `onCreateScope` Callback which will be invoked when a new scope is\n  //     created.\n  //   - `onDestroyScope` Callback which will be invoked when the current scope\n  //     is destroyed.\n  //\n  // Example:\n  //\n  //     var parser = require('luaparser');\n  //     parser.parse('i = 0');\n\n  exports.parse = parse;\n\n  var versionFeatures = {\n    '5.1': {\n    },\n    '5.2': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      relaxedBreak: true\n    },\n    '5.3': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      bitwiseOperators: true,\n      integerDivision: true,\n      relaxedBreak: true\n    },\n    'LuaJIT': {\n      // XXX: LuaJIT language features may depend on compilation options; may need to\n      // rethink how to handle this. Specifically, there is a LUAJIT_ENABLE_LUA52COMPAT\n      // that removes contextual goto. Maybe add 'LuaJIT-5.2compat' as well?\n      labels: true,\n      contextualGoto: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      imaginaryNumbers: true,\n      integerSuffixes: true\n    }\n  };\n\n  function parse(_input, _options) {\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\n      _options = _input;\n      _input = undefined;\n    }\n    if (!_options) _options = {};\n\n    input = _input || '';\n    options = assign({}, defaultOptions, _options);\n\n    // Rewind the lexer\n    index = 0;\n    line = 1;\n    lineStart = 0;\n    length = input.length;\n    // When tracking identifier scope, initialize with an empty scope.\n    scopes = [[]];\n    scopeDepth = 0;\n    globals = [];\n    locations = [];\n\n    if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {\n      throw new Error(sprintf(\"Lua version '%1' not supported\", options.luaVersion));\n    }\n\n    features = assign({}, versionFeatures[options.luaVersion]);\n    if (options.extendedIdentifiers !== void 0)\n      features.extendedIdentifiers = !!options.extendedIdentifiers;\n\n    if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {\n      throw new Error(sprintf(\"Encoding mode '%1' not supported\", options.encodingMode));\n    }\n\n    encodingMode = encodingModes[options.encodingMode];\n\n    if (options.comments) comments = [];\n    if (!options.wait) return end();\n    return exports;\n  }\n\n  // Write to the source code buffer without beginning the parse.\n  exports.write = write;\n\n  function write(_input) {\n    input += String(_input);\n    length = input.length;\n    return exports;\n  }\n\n  // Send an EOF and begin parsing.\n  exports.end = end;\n\n  function end(_input) {\n    if ('undefined' !== typeof _input) write(_input);\n\n    // Ignore shebangs.\n    if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n      return line.replace(/./g, ' ');\n    });\n\n    length = input.length;\n    trackLocations = options.locations || options.ranges;\n    // Initialize with a lookahead token.\n    lookahead = lex();\n\n    var chunk = parseChunk();\n    if (options.comments) chunk.comments = comments;\n    if (options.scope) chunk.globals = globals;\n\n    /* istanbul ignore if */\n    if (locations.length > 0)\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n\n    return chunk;\n  }\n\n}));\n/* vim: set sw=2 ts=2 et tw=79 : */\n"],
  "mappings": "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",
  "names": ["exports", "end", "index", "length", "token", "next", "line"]
}
