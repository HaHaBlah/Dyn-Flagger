{
  "version": 3,
  "sources": ["../bundle-Ugahcn/strip-cf-connecting-ip-header.js", "../../../node_modules/luaparse/luaparse.js", "../../../fandomProcessor.js", "../../../functions/api/fandom-data.js", "functionsRoutes-0.3416367474695612.mjs", "../bundle-Ugahcn/middleware-loader.entry.ts", "../bundle-Ugahcn/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/pages-template-worker.ts", "../../../node_modules/wrangler/node_modules/path-to-regexp/src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../../../node_modules/wrangler/templates/middleware/common.ts"],
  "sourceRoot": "C:\\Users\\asus\\OneDrive\\Desktop\\Projects\\Dyn-Flagger\\.wrangler\\tmp\\pages-FP7VkJ\\functionsWorker-0.956993438818216.mjs",
  "sourcesContent": ["function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "/* global exports:true, module:true, require:true, define:true, global:true */\n\n(function (root, name, factory) {\n  'use strict';\n\n  // Used to determine if values are of the language type `Object`\n  var objectTypes = {\n        'function': true\n      , 'object': true\n    }\n    // Detect free variable `exports`\n    , freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports\n    // Detect free variable `module`\n    , freeModule = objectTypes[typeof module] && module && !module.nodeType && module\n    // Detect free variable `global`, from Node.js or Browserified code, and\n    // use it as `window`\n    , freeGlobal = freeExports && freeModule && typeof global === 'object' && global\n    // Detect the popular CommonJS extension `module.exports`\n    , moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /* istanbul ignore else */\n  if (freeGlobal && (freeGlobal.global === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.window === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Some AMD build optimizers, like r.js, check for specific condition\n  // patterns like the following:\n  /* istanbul ignore if */\n  if (typeof define === 'function' &&\n      /* istanbul ignore next */ typeof define.amd === 'object' &&\n      /* istanbul ignore next */ define.amd) {\n    // defined as an anonymous module.\n    define(['exports'], factory);\n    // In case the source has been processed and wrapped in a define module use\n    // the supplied `exports` object.\n    if (freeExports && moduleExports) factory(freeModule.exports);\n  }\n  // check for `exports` after `define` in case a build optimizer adds an\n  // `exports` object\n  else /* istanbul ignore else */ if (freeExports && freeModule) {\n    // in Node.js or RingoJS v0.8.0+\n    /* istanbul ignore else */\n    if (moduleExports) factory(freeModule.exports);\n    // in RingoJS v0.7.0-\n    else factory(freeExports);\n  }\n  // in a browser or Rhino\n  else {\n    factory((root[name] = {}));\n  }\n}(this, 'luaparse', function (exports) {\n  'use strict';\n\n  exports.version = \"0.3.1\";\n\n  var input, options, length, features, encodingMode;\n\n  // Options can be set either globally on the parser object through\n  // defaultOptions, or during the parse call.\n  var defaultOptions = exports.defaultOptions = {\n    // Explicitly tell the parser when the input ends.\n      wait: false\n    // Store comments as an array in the chunk object.\n    , comments: true\n    // Track identifier scopes by adding an isLocal attribute to each\n    // identifier-node.\n    , scope: false\n    // Store location information on each syntax node as\n    // `loc: { start: { line, column }, end: { line, column } }`.\n    , locations: false\n    // Store the start and end character locations on each syntax node as\n    // `range: [start, end]`.\n    , ranges: false\n    // A callback which will be invoked when a syntax node has been completed.\n    // The node which has been created will be passed as the only parameter.\n    , onCreateNode: null\n    // A callback which will be invoked when a new scope is created.\n    , onCreateScope: null\n    // A callback which will be invoked when the current scope is destroyed.\n    , onDestroyScope: null\n    // A callback which will be invoked when a local variable is declared in the current scope.\n    // The variable's name will be passed as the only parameter\n    , onLocalDeclaration: null\n    // The version of Lua targeted by the parser (string; allowed values are\n    // '5.1', '5.2', '5.3').\n    , luaVersion: '5.1'\n    // Encoding mode: how to interpret code units higher than U+007F in input\n    , encodingMode: 'none'\n  };\n\n  function encodeUTF8(codepoint, highMask) {\n    highMask = highMask || 0;\n\n    if (codepoint < 0x80) {\n      return String.fromCharCode(codepoint);\n    } else if (codepoint < 0x800) {\n      return String.fromCharCode(\n        highMask | 0xc0 |  (codepoint >>  6)        ,\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else if (codepoint < 0x10000) {\n      return String.fromCharCode(\n        highMask | 0xe0 |  (codepoint >> 12)        ,\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else /* istanbul ignore else */ if (codepoint < 0x110000) {\n      return String.fromCharCode(\n        highMask | 0xf0 |  (codepoint >> 18)        ,\n        highMask | 0x80 | ((codepoint >> 12) & 0x3f),\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else {\n      // TODO: Lua 5.4 allows up to six-byte sequences, as in UTF-8:1993\n      return null;\n    }\n  }\n\n  function toHex(num, digits) {\n    var result = num.toString(16);\n    while (result.length < digits)\n      result = '0' + result;\n    return result;\n  }\n\n  function checkChars(rx) {\n    return function (s) {\n      var m = rx.exec(s);\n      if (!m)\n        return s;\n      raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());\n    };\n  }\n\n  var encodingModes = {\n    // `pseudo-latin1` encoding mode: assume the input was decoded with the latin1 encoding\n    // WARNING: latin1 does **NOT** mean cp1252 here like in the bone-headed WHATWG standard;\n    // it means true ISO/IEC 8859-1 identity-mapped to Basic Latin and Latin-1 Supplement blocks\n    'pseudo-latin1': {\n      fixup: checkChars(/[^\\x00-\\xff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint);\n      },\n    },\n\n    // `x-user-defined` encoding mode: assume the input was decoded with the WHATWG `x-user-defined` encoding\n    'x-user-defined': {\n      fixup: checkChars(/[^\\x00-\\x7f\\uf780-\\uf7ff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        if (value >= 0x80)\n          return String.fromCharCode(value | 0xf700);\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint, 0xf700);\n      }\n    },\n\n    // `none` encoding mode: disregard intrepretation of string literals, leave identifiers as-is\n    'none': {\n      discardStrings: true,\n      fixup: function (s) {\n        return s;\n      },\n      encodeByte: function (value) {\n        return '';\n      },\n      encodeUTF8: function (codepoint) {\n        return '';\n      }\n    }\n  };\n\n  // The available tokens expressed as enum flags so they can be checked with\n  // bitwise operations.\n\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\n    , NilLiteral = 128, VarargLiteral = 256;\n\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\n  };\n\n  // As this parser is a bit different from luas own, the error messages\n  // will be different in some situations.\n\n  var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\''\n    , unexpectedEOF: 'unexpected symbol near \\'<eof>\\''\n    , expected: '\\'%1\\' expected near \\'%2\\''\n    , expectedToken: '%1 expected near \\'%2\\''\n    , unfinishedString: 'unfinished string near \\'%1\\''\n    , malformedNumber: 'malformed number near \\'%1\\''\n    , decimalEscapeTooLarge: 'decimal escape too large near \\'%1\\''\n    , invalidEscape: 'invalid escape sequence near \\'%1\\''\n    , hexadecimalDigitExpected: 'hexadecimal digit expected near \\'%1\\''\n    , braceExpected: 'missing \\'%1\\' near \\'%2\\''\n    , tooLargeCodepoint: 'UTF-8 value too large near \\'%1\\''\n    , unfinishedLongString: 'unfinished long string (starting at line %1) near \\'%2\\''\n    , unfinishedLongComment: 'unfinished long comment (starting at line %1) near \\'%2\\''\n    , ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \\'%1\\''\n    , noLoopToBreak: 'no loop to break near \\'%1\\''\n    , labelAlreadyDefined: 'label \\'%1\\' already defined on line %2'\n    , labelNotVisible: 'no visible label \\'%1\\' for <goto>'\n    , gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \\'%2\\''\n    , cannotUseVararg: 'cannot use \\'...\\' outside a vararg function near \\'%1\\''\n    , invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'\n  };\n\n  // ### Abstract Syntax Tree\n  //\n  // The default AST structure is inspired by the Mozilla Parser API but can\n  // easily be customized by overriding these functions.\n\n  var ast = exports.ast = {\n      labelStatement: function(label) {\n      return {\n          type: 'LabelStatement'\n        , label: label\n      };\n    }\n\n    , breakStatement: function() {\n      return {\n          type: 'BreakStatement'\n      };\n    }\n\n    , gotoStatement: function(label) {\n      return {\n          type: 'GotoStatement'\n        , label: label\n      };\n    }\n\n    , returnStatement: function(args) {\n      return {\n          type: 'ReturnStatement'\n        , 'arguments': args\n      };\n    }\n\n    , ifStatement: function(clauses) {\n      return {\n          type: 'IfStatement'\n        , clauses: clauses\n      };\n    }\n    , ifClause: function(condition, body) {\n      return {\n          type: 'IfClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseifClause: function(condition, body) {\n      return {\n          type: 'ElseifClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseClause: function(body) {\n      return {\n          type: 'ElseClause'\n        , body: body\n      };\n    }\n\n    , whileStatement: function(condition, body) {\n      return {\n          type: 'WhileStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , doStatement: function(body) {\n      return {\n          type: 'DoStatement'\n        , body: body\n      };\n    }\n\n    , repeatStatement: function(condition, body) {\n      return {\n          type: 'RepeatStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , localStatement: function(variables, init) {\n      return {\n          type: 'LocalStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , assignmentStatement: function(variables, init) {\n      return {\n          type: 'AssignmentStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , callStatement: function(expression) {\n      return {\n          type: 'CallStatement'\n        , expression: expression\n      };\n    }\n\n    , functionStatement: function(identifier, parameters, isLocal, body) {\n      return {\n          type: 'FunctionDeclaration'\n        , identifier: identifier\n        , isLocal: isLocal\n        , parameters: parameters\n        , body: body\n      };\n    }\n\n    , forNumericStatement: function(variable, start, end, step, body) {\n      return {\n          type: 'ForNumericStatement'\n        , variable: variable\n        , start: start\n        , end: end\n        , step: step\n        , body: body\n      };\n    }\n\n    , forGenericStatement: function(variables, iterators, body) {\n      return {\n          type: 'ForGenericStatement'\n        , variables: variables\n        , iterators: iterators\n        , body: body\n      };\n    }\n\n    , chunk: function(body) {\n      return {\n          type: 'Chunk'\n        , body: body\n      };\n    }\n\n    , identifier: function(name) {\n      return {\n          type: 'Identifier'\n        , name: name\n      };\n    }\n\n    , literal: function(type, value, raw) {\n      type = (type === StringLiteral) ? 'StringLiteral'\n        : (type === NumericLiteral) ? 'NumericLiteral'\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\n        : (type === NilLiteral) ? 'NilLiteral'\n        : 'VarargLiteral';\n\n      return {\n          type: type\n        , value: value\n        , raw: raw\n      };\n    }\n\n    , tableKey: function(key, value) {\n      return {\n          type: 'TableKey'\n        , key: key\n        , value: value\n      };\n    }\n    , tableKeyString: function(key, value) {\n      return {\n          type: 'TableKeyString'\n        , key: key\n        , value: value\n      };\n    }\n    , tableValue: function(value) {\n      return {\n          type: 'TableValue'\n        , value: value\n      };\n    }\n\n\n    , tableConstructorExpression: function(fields) {\n      return {\n          type: 'TableConstructorExpression'\n        , fields: fields\n      };\n    }\n    , binaryExpression: function(operator, left, right) {\n      var type = ('and' === operator || 'or' === operator) ?\n        'LogicalExpression' :\n        'BinaryExpression';\n\n      return {\n          type: type\n        , operator: operator\n        , left: left\n        , right: right\n      };\n    }\n    , unaryExpression: function(operator, argument) {\n      return {\n          type: 'UnaryExpression'\n        , operator: operator\n        , argument: argument\n      };\n    }\n    , memberExpression: function(base, indexer, identifier) {\n      return {\n          type: 'MemberExpression'\n        , indexer: indexer\n        , identifier: identifier\n        , base: base\n      };\n    }\n\n    , indexExpression: function(base, index) {\n      return {\n          type: 'IndexExpression'\n        , base: base\n        , index: index\n      };\n    }\n\n    , callExpression: function(base, args) {\n      return {\n          type: 'CallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , tableCallExpression: function(base, args) {\n      return {\n          type: 'TableCallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , stringCallExpression: function(base, argument) {\n      return {\n          type: 'StringCallExpression'\n        , base: base\n        , argument: argument\n      };\n    }\n\n    , comment: function(value, raw) {\n      return {\n          type: 'Comment'\n        , value: value\n        , raw: raw\n      };\n    }\n  };\n\n  // Wrap up the node object.\n\n  function finishNode(node) {\n    // Pop a `Marker` off the location-array and attach its location data.\n    if (trackLocations) {\n      var location = locations.pop();\n      location.complete();\n      location.bless(node);\n    }\n    if (options.onCreateNode) options.onCreateNode(node);\n    return node;\n  }\n\n\n  // Helpers\n  // -------\n\n  var slice = Array.prototype.slice\n    , toString = Object.prototype.toString\n    ;\n\n  var indexOf = /* istanbul ignore next */ function (array, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i] === element) return i;\n    }\n    return -1;\n  };\n\n  /* istanbul ignore else */\n  if (Array.prototype.indexOf)\n    indexOf = function (array, element) {\n      return array.indexOf(element);\n    };\n\n  // Iterate through an array of objects and return the index of an object\n  // with a matching property.\n\n  function indexOfObject(array, property, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i][property] === element) return i;\n    }\n    return -1;\n  }\n\n  // A sprintf implementation using %index (beginning at 1) to input\n  // arguments in the format string.\n  //\n  // Example:\n  //\n  //     // Unexpected function in token\n  //     sprintf('Unexpected %2 in %1.', 'token', 'function');\n\n  function sprintf(format) {\n    var args = slice.call(arguments, 1);\n    format = format.replace(/%(\\d)/g, function (match, index) {\n      return '' + args[index - 1] || /* istanbul ignore next */ '';\n    });\n    return format;\n  }\n\n  // Polyfill for `Object.assign`.\n\n  var assign = /* istanbul ignore next */ function (dest) {\n    var args = slice.call(arguments, 1)\n      , src, prop;\n\n    for (var i = 0, length = args.length; i < length; ++i) {\n      src = args[i];\n      for (prop in src)\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(src, prop)) {\n          dest[prop] = src[prop];\n        }\n    }\n\n    return dest;\n  };\n\n  /* istanbul ignore else */\n  if (Object.assign)\n    assign = Object.assign;\n\n  // ### Error functions\n\n  exports.SyntaxError = SyntaxError;\n\n  // XXX: Eliminate this function and change the error type to be different from SyntaxError.\n  // This will unfortunately be a breaking change, because some downstream users depend\n  // on the error thrown being an instance of SyntaxError. For example, the Ace editor:\n  // <https://github.com/ajaxorg/ace/blob/4c7e5eb3f5d5ca9434847be51834a4e41661b852/lib/ace/mode/lua_worker.js#L55>\n\n  function fixupError(e) {\n    /* istanbul ignore if */\n    if (!Object.create)\n      return e;\n    return Object.create(e, {\n      'line': { 'writable': true, value: e.line },\n      'index': { 'writable': true, value: e.index },\n      'column': { 'writable': true, value: e.column }\n    });\n  }\n\n  // #### Raise an exception.\n  //\n  // Raise an exception by passing a token, a string format and its paramters.\n  //\n  // The passed tokens location will automatically be added to the error\n  // message if it exists, if not it will default to the lexers current\n  // position.\n  //\n  // Example:\n  //\n  //     // [1:0] expected [ near (\n  //     raise(token, \"expected %1 near %2\", '[', token.value);\n\n  function raise(token) {\n    var message = sprintf.apply(null, slice.call(arguments, 1))\n      , error, col;\n\n    if (token === null || typeof token.line === 'undefined') {\n      col = index - lineStart + 1;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));\n      error.index = index;\n      error.line = line;\n      error.column = col;\n    } else {\n      col = token.range[0] - token.lineStart;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));\n      error.line = token.line;\n      error.index = token.range[0];\n      error.column = col;\n    }\n    throw error;\n  }\n\n  function tokenValue(token) {\n    var raw = input.slice(token.range[0], token.range[1]);\n    if (raw)\n      return raw;\n    return token.value;\n  }\n\n  // #### Raise an unexpected token error.\n  //\n  // Example:\n  //\n  //     // expected <name> near '0'\n  //     raiseUnexpectedToken('<name>', token);\n\n  function raiseUnexpectedToken(type, token) {\n    raise(token, errors.expectedToken, type, tokenValue(token));\n  }\n\n  // #### Raise a general unexpected error\n  //\n  // Usage should pass either a token object or a symbol string which was\n  // expected. We can also specify a nearby token such as <eof>, this will\n  // default to the currently active token.\n  //\n  // Example:\n  //\n  //     // Unexpected symbol 'end' near '<eof>'\n  //     unexpected(token);\n  //\n  // If there's no token in the buffer it means we have reached <eof>.\n\n  function unexpected(found) {\n    var near = tokenValue(lookahead);\n    if ('undefined' !== typeof found.type) {\n      var type;\n      switch (found.type) {\n        case StringLiteral:   type = 'string';      break;\n        case Keyword:         type = 'keyword';     break;\n        case Identifier:      type = 'identifier';  break;\n        case NumericLiteral:  type = 'number';      break;\n        case Punctuator:      type = 'symbol';      break;\n        case BooleanLiteral:  type = 'boolean';     break;\n        case NilLiteral:\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\n        case EOF:\n          return raise(found, errors.unexpectedEOF);\n      }\n      return raise(found, errors.unexpected, type, tokenValue(found), near);\n    }\n    return raise(found, errors.unexpected, 'symbol', found, near);\n  }\n\n  // Lexer\n  // -----\n  //\n  // The lexer, or the tokenizer reads the input string character by character\n  // and derives a token left-right. To be as efficient as possible the lexer\n  // prioritizes the common cases such as identifiers. It also works with\n  // character codes instead of characters as string comparisons was the\n  // biggest bottleneck of the parser.\n  //\n  // If `options.comments` is enabled, all comments encountered will be stored\n  // in an array which later will be appended to the chunk object. If disabled,\n  // they will simply be disregarded.\n  //\n  // When the lexer has derived a valid token, it will be returned as an object\n  // containing its value and as well as its position in the input string (this\n  // is always enabled to provide proper debug messages).\n  //\n  // `lex()` starts lexing and returns the following token in the stream.\n\n  var index\n    , token\n    , previousToken\n    , lookahead\n    , comments\n    , tokenStart\n    , line\n    , lineStart;\n\n  exports.lex = lex;\n\n  function lex() {\n    skipWhiteSpace();\n\n    // Skip comments beginning with --\n    while (45 === input.charCodeAt(index) &&\n           45 === input.charCodeAt(index + 1)) {\n      scanComment();\n      skipWhiteSpace();\n    }\n    if (index >= length) return {\n        type : EOF\n      , value: '<eof>'\n      , line: line\n      , lineStart: lineStart\n      , range: [index, index]\n    };\n\n    var charCode = input.charCodeAt(index)\n      , next = input.charCodeAt(index + 1);\n\n    // Memorize the range index where the token begins.\n    tokenStart = index;\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n\n    switch (charCode) {\n      case 39: case 34: // '\"\n        return scanStringLiteral();\n\n      case 48: case 49: case 50: case 51: case 52: case 53:\n      case 54: case 55: case 56: case 57: // 0-9\n        return scanNumericLiteral();\n\n      case 46: // .\n        // If the dot is followed by a digit it's a float.\n        if (isDecDigit(next)) return scanNumericLiteral();\n        if (46 === next) {\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n          return scanPunctuator('..');\n        }\n        return scanPunctuator('.');\n\n      case 61: // =\n        if (61 === next) return scanPunctuator('==');\n        return scanPunctuator('=');\n\n      case 62: // >\n        if (features.bitwiseOperators)\n          if (62 === next) return scanPunctuator('>>');\n        if (61 === next) return scanPunctuator('>=');\n        return scanPunctuator('>');\n\n      case 60: // <\n        if (features.bitwiseOperators)\n          if (60 === next) return scanPunctuator('<<');\n        if (61 === next) return scanPunctuator('<=');\n        return scanPunctuator('<');\n\n      case 126: // ~\n        if (61 === next) return scanPunctuator('~=');\n        if (!features.bitwiseOperators)\n          break;\n        return scanPunctuator('~');\n\n      case 58: // :\n        if (features.labels)\n          if (58 === next) return scanPunctuator('::');\n        return scanPunctuator(':');\n\n      case 91: // [\n        // Check for a multiline string, they begin with [= or [[\n        if (91 === next || 61 === next) return scanLongStringLiteral();\n        return scanPunctuator('[');\n\n      case 47: // /\n        // Check for integer division op (//)\n        if (features.integerDivision)\n          if (47 === next) return scanPunctuator('//');\n        return scanPunctuator('/');\n\n      case 38: case 124: // & |\n        if (!features.bitwiseOperators)\n          break;\n\n        /* fall through */\n      case 42: case 94: case 37: case 44: case 123: case 125:\n      case 93: case 40: case 41: case 59: case 35: case 45:\n      case 43: // * ^ % , { } ] ( ) ; # - +\n        return scanPunctuator(input.charAt(index));\n    }\n\n    return unexpected(input.charAt(index));\n  }\n\n  // Whitespace has no semantic meaning in lua so simply skip ahead while\n  // tracking the encounted newlines. Any kind of eol sequence is counted as a\n  // single line.\n\n  function consumeEOL() {\n    var charCode = input.charCodeAt(index)\n      , peekCharCode = input.charCodeAt(index + 1);\n\n    if (isLineTerminator(charCode)) {\n      // Count \\n\\r and \\r\\n as one newline.\n      if (10 === charCode && 13 === peekCharCode) ++index;\n      if (13 === charCode && 10 === peekCharCode) ++index;\n      ++line;\n      lineStart = ++index;\n\n      return true;\n    }\n    return false;\n  }\n\n  function skipWhiteSpace() {\n    while (index < length) {\n      var charCode = input.charCodeAt(index);\n      if (isWhiteSpace(charCode)) {\n        ++index;\n      } else if (!consumeEOL()) {\n        break;\n      }\n    }\n  }\n\n  // Identifiers, keywords, booleans and nil all look the same syntax wise. We\n  // simply go through them one by one and defaulting to an identifier if no\n  // previous case matched.\n\n  function scanIdentifierOrKeyword() {\n    var value, type;\n\n    // Slicing the input string is prefered before string concatenation in a\n    // loop for performance reasons.\n    while (isIdentifierPart(input.charCodeAt(++index)));\n    value = encodingMode.fixup(input.slice(tokenStart, index));\n\n    // Decide on the token type and possibly cast the value.\n    if (isKeyword(value)) {\n      type = Keyword;\n    } else if ('true' === value || 'false' === value) {\n      type = BooleanLiteral;\n      value = ('true' === value);\n    } else if ('nil' === value) {\n      type = NilLiteral;\n      value = null;\n    } else {\n      type = Identifier;\n    }\n\n    return {\n        type: type\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Once a punctuator reaches this function it should already have been\n  // validated so we simply return it as a token.\n\n  function scanPunctuator(value) {\n    index += value.length;\n    return {\n        type: Punctuator\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // A vararg literal consists of three dots.\n\n  function scanVarargLiteral() {\n    index += 3;\n    return {\n        type: VarargLiteral\n      , value: '...'\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Find the string literal by matching the delimiter marks used.\n\n  function scanStringLiteral() {\n    var delimiter = input.charCodeAt(index++)\n      , beginLine = line\n      , beginLineStart = lineStart\n      , stringStart = index\n      , string = encodingMode.discardStrings ? null : ''\n      , charCode;\n\n    for (;;) {\n      charCode = input.charCodeAt(index++);\n      if (delimiter === charCode) break;\n      // EOF or `\\n` terminates a string literal. If we haven't found the\n      // ending delimiter by now, raise an exception.\n      if (index > length || isLineTerminator(charCode)) {\n        string += input.slice(stringStart, index - 1);\n        raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));\n      }\n      if (92 === charCode) { // backslash\n        if (!encodingMode.discardStrings) {\n          var beforeEscape = input.slice(stringStart, index - 1);\n          string += encodingMode.fixup(beforeEscape);\n        }\n        var escapeValue = readEscapeSequence();\n        if (!encodingMode.discardStrings)\n          string += escapeValue;\n        stringStart = index;\n      }\n    }\n    if (!encodingMode.discardStrings) {\n      string += encodingMode.encodeByte(null);\n      string += encodingMode.fixup(input.slice(stringStart, index - 1));\n    }\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Expect a multiline string literal and return it as a regular string\n  // literal, if it doesn't validate into a valid multiline string, throw an\n  // exception.\n\n  function scanLongStringLiteral() {\n    var beginLine = line\n      , beginLineStart = lineStart\n      , string = readLongString(false);\n    // Fail if it's not a multiline literal.\n    if (false === string) raise(token, errors.expected, '[', tokenValue(token));\n\n    return {\n        type: StringLiteral\n      , value: encodingMode.discardStrings ? null : encodingMode.fixup(string)\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Numeric literals will be returned as floating-point numbers instead of\n  // strings. The raw value should be retrieved from slicing the input string\n  // later on in the process.\n  //\n  // If a hexadecimal number is encountered, it will be converted.\n\n  function scanNumericLiteral() {\n    var character = input.charAt(index)\n      , next = input.charAt(index + 1);\n\n    var literal = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\n      readHexLiteral() : readDecLiteral();\n\n    var foundImaginaryUnit = readImaginaryUnitSuffix()\n      , foundInt64Suffix = readInt64Suffix();\n\n    if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n    }\n\n    return {\n        type: NumericLiteral\n      , value: literal.value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  function readImaginaryUnitSuffix() {\n    if (!features.imaginaryNumbers) return;\n\n    // Imaginary unit number suffix is optional.\n    // See http://luajit.org/ext_ffi_api.html#literals\n    if ('iI'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function readInt64Suffix() {\n    if (!features.integerSuffixes) return;\n\n    // Int64/uint64 number suffix is optional.\n    // See http://luajit.org/ext_ffi_api.html#literals\n\n    if ('uU'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'ULL';\n        } else {\n          // UL but no L\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      } else {\n        // U but no L\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      }\n    } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'LL';\n        } else {\n          // First L but no second L\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n    }\n  }\n\n  // Lua hexadecimals have an optional fraction part and an optional binary\n  // exoponent part. These are not included in JavaScript so we will compute\n  // all three parts separately and then sum them up at the end of the function\n  // with the following algorithm.\n  //\n  //     Digit := toDec(digit)\n  //     Fraction := toDec(fraction) / 16 ^ fractionCount\n  //     BinaryExp := 2 ^ binaryExp\n  //     Number := ( Digit + Fraction ) * BinaryExp\n\n  function readHexLiteral() {\n    var fraction = 0 // defaults to 0 as it gets summed\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\n      , binarySign = 1 // positive\n      , digit, fractionStart, exponentStart, digitStart;\n\n    digitStart = index += 2; // Skip 0x part\n\n    // A minimum of one hex digit is required.\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n    while (isHexDigit(input.charCodeAt(index))) ++index;\n    // Convert the hexadecimal digit to base 10.\n    digit = parseInt(input.slice(digitStart, index), 16);\n\n    // Fraction part is optional.\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      fractionStart = ++index;\n\n      while (isHexDigit(input.charCodeAt(index))) ++index;\n      fraction = input.slice(fractionStart, index);\n\n      // Empty fraction parts should default to 0, others should be converted\n      // 0.x form so we can use summation at the end.\n      fraction = (fractionStart === index) ? 0\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n    }\n\n    // Binary exponents are optional\n    var foundBinaryExponent = false;\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n      foundBinaryExponent = true;\n      ++index;\n\n      // Sign part is optional and defaults to 1 (positive).\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\n\n      exponentStart = index;\n\n      // The binary exponent sign requires a decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n      binaryExponent = input.slice(exponentStart, index);\n\n      // Calculate the binary exponent of the number.\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\n    }\n\n    return {\n      value: (digit + fraction) * binaryExponent,\n      hasFractionPart: foundFraction || foundBinaryExponent\n    };\n  }\n\n  // Decimal numbers are exactly the same in Lua and in JavaScript, because of\n  // this we check where the token ends and then parse it with native\n  // functions.\n\n  function readDecLiteral() {\n    while (isDecDigit(input.charCodeAt(index))) ++index;\n    // Fraction part is optional\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      ++index;\n      // Fraction part defaults to 0\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    // Exponent part is optional.\n    var foundExponent = false;\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n      foundExponent = true;\n      ++index;\n      // Sign part is optional.\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;\n      // An exponent is required to contain at least one decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    return {\n      value: parseFloat(input.slice(tokenStart, index)),\n      hasFractionPart: foundFraction || foundExponent\n    };\n  }\n\n  function readUnicodeEscapeSequence() {\n    var sequenceStart = index++;\n\n    if (input.charAt(index++) !== '{')\n      raise(null, errors.braceExpected, '{', '\\\\' + input.slice(sequenceStart, index));\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n\n    while (input.charCodeAt(index) === 0x30) ++index;\n    var escStart = index;\n\n    while (isHexDigit(input.charCodeAt(index))) {\n      ++index;\n      if (index - escStart > 6)\n        raise(null, errors.tooLargeCodepoint, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var b = input.charAt(index++);\n    if (b !== '}') {\n      if ((b === '\"') || (b === \"'\"))\n        raise(null, errors.braceExpected, '}', '\\\\' + input.slice(sequenceStart, index--));\n      else\n        raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);\n    var frag = '\\\\' + input.slice(sequenceStart, index);\n\n    if (codepoint > 0x10ffff) {\n      raise(null, errors.tooLargeCodepoint, frag);\n    }\n\n    return encodingMode.encodeUTF8(codepoint, frag);\n  }\n\n  // Translate escape sequences to the actual characters.\n  function readEscapeSequence() {\n    var sequenceStart = index;\n    switch (input.charAt(index)) {\n      // Lua allow the following escape sequences.\n      case 'a': ++index; return '\\x07';\n      case 'n': ++index; return '\\n';\n      case 'r': ++index; return '\\r';\n      case 't': ++index; return '\\t';\n      case 'v': ++index; return '\\x0b';\n      case 'b': ++index; return '\\b';\n      case 'f': ++index; return '\\f';\n\n      // Backslash at the end of the line. We treat all line endings as equivalent,\n      // and as representing the [LF] character (code 10). Lua 5.1 through 5.3\n      // have been verified to behave the same way.\n      case '\\r':\n      case '\\n':\n        consumeEOL();\n        return '\\n';\n\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n        // \\ddd, where ddd is a sequence of up to three decimal digits.\n        while (isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3) ++index;\n\n        var frag = input.slice(sequenceStart, index);\n        var ddd = parseInt(frag, 10);\n        if (ddd > 255) {\n          raise(null, errors.decimalEscapeTooLarge, '\\\\' + ddd);\n        }\n        return encodingMode.encodeByte(ddd, '\\\\' + frag);\n\n      case 'z':\n        if (features.skipWhitespaceEscape) {\n          ++index;\n          skipWhiteSpace();\n          return '';\n        }\n        break;\n\n      case 'x':\n        if (features.hexEscapes) {\n          // \\xXX, where XX is a sequence of exactly two hexadecimal digits\n          if (isHexDigit(input.charCodeAt(index + 1)) &&\n              isHexDigit(input.charCodeAt(index + 2))) {\n            index += 3;\n            return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\\\' + input.slice(sequenceStart, index));\n          }\n          raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index + 2));\n        }\n        break;\n\n      case 'u':\n        if (features.unicodeEscapes)\n          return readUnicodeEscapeSequence();\n        break;\n\n      case '\\\\': case '\"': case \"'\":\n        return input.charAt(index++);\n    }\n\n    if (features.strictEscapes)\n      raise(null, errors.invalidEscape, '\\\\' + input.slice(sequenceStart, index + 1));\n    return input.charAt(index++);\n  }\n\n  // Comments begin with -- after which it will be decided if they are\n  // multiline comments or not.\n  //\n  // The multiline functionality works the exact same way as with string\n  // literals so we reuse the functionality.\n\n  function scanComment() {\n    tokenStart = index;\n    index += 2; // --\n\n    var character = input.charAt(index)\n      , content = ''\n      , isLong = false\n      , commentStart = index\n      , lineStartComment = lineStart\n      , lineComment = line;\n\n    if ('[' === character) {\n      content = readLongString(true);\n      // This wasn't a multiline comment after all.\n      if (false === content) content = character;\n      else isLong = true;\n    }\n    // Scan until next line as long as it's not a multiline comment.\n    if (!isLong) {\n      while (index < length) {\n        if (isLineTerminator(input.charCodeAt(index))) break;\n        ++index;\n      }\n      if (options.comments) content = input.slice(commentStart, index);\n    }\n\n    if (options.comments) {\n      var node = ast.comment(content, input.slice(tokenStart, index));\n\n      // `Marker`s depend on tokens available in the parser and as comments are\n      // intercepted in the lexer all location data is set manually.\n      if (options.locations) {\n        node.loc = {\n            start: { line: lineComment, column: tokenStart - lineStartComment }\n          , end: { line: line, column: index - lineStart }\n        };\n      }\n      if (options.ranges) {\n        node.range = [tokenStart, index];\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      comments.push(node);\n    }\n  }\n\n  // Read a multiline string by calculating the depth of `=` characters and\n  // then appending until an equal depth is found.\n\n  function readLongString(isComment) {\n    var level = 0\n      , content = ''\n      , terminator = false\n      , character, stringStart, firstLine = line;\n\n    ++index; // [\n\n    // Calculate the depth of the comment.\n    while ('=' === input.charAt(index + level)) ++level;\n    // Exit, this is not a long string afterall.\n    if ('[' !== input.charAt(index + level)) return false;\n\n    index += level + 1;\n\n    // If the first character is a newline, ignore it and begin on next line.\n    if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n    stringStart = index;\n    while (index < length) {\n      // To keep track of line numbers run the `consumeEOL()` which increments\n      // its counter.\n      while (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n      character = input.charAt(index++);\n\n      // Once the delimiter is found, iterate through the depth count and see\n      // if it matches.\n      if (']' === character) {\n        terminator = true;\n        for (var i = 0; i < level; ++i) {\n          if ('=' !== input.charAt(index + i)) terminator = false;\n        }\n        if (']' !== input.charAt(index + level)) terminator = false;\n      }\n\n      // We reached the end of the multiline string. Get out now.\n      if (terminator) {\n        content += input.slice(stringStart, index - 1);\n        index += level + 1;\n        return content;\n      }\n    }\n\n    raise(null, isComment ?\n                errors.unfinishedLongComment :\n                errors.unfinishedLongString,\n          firstLine, '<eof>');\n  }\n\n  // ## Lex functions and helpers.\n\n  // Read the next token.\n  //\n  // This is actually done by setting the current token to the lookahead and\n  // reading in the new lookahead token.\n\n  function next() {\n    previousToken = token;\n    token = lookahead;\n    lookahead = lex();\n  }\n\n  // Consume a token if its value matches. Once consumed or not, return the\n  // success of the operation.\n\n  function consume(value) {\n    if (value === token.value) {\n      next();\n      return true;\n    }\n    return false;\n  }\n\n  // Expect the next token value to match. If not, throw an exception.\n\n  function expect(value) {\n    if (value === token.value) next();\n    else raise(token, errors.expected, value, tokenValue(token));\n  }\n\n  // ### Validation functions\n\n  function isWhiteSpace(charCode) {\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n  }\n\n  function isLineTerminator(charCode) {\n    return 10 === charCode || 13 === charCode;\n  }\n\n  function isDecDigit(charCode) {\n    return charCode >= 48 && charCode <= 57;\n  }\n\n  function isHexDigit(charCode) {\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\n  }\n\n  // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards\n  // identifiers cannot use 'locale-dependent' letters (i.e. dependent on the C locale).\n  // On the other hand, LuaJIT allows arbitrary octets \u2265 128 in identifiers.\n\n  function isIdentifierStart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode)\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  function isIdentifierPart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57))\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)\n  //\n  // `true`, `false` and `nil` will not be considered keywords, but literals.\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n      case 3:\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n      case 4:\n        if ('else' === id || 'then' === id)\n          return true;\n        if (features.labels && !features.contextualGoto)\n          return ('goto' === id);\n        return false;\n      case 5:\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n      case 6:\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\n      case 8:\n        return 'function' === id;\n    }\n    return false;\n  }\n\n  function isUnary(token) {\n    if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n    if (Keyword === token.type) return 'not' === token.value;\n    return false;\n  }\n\n  // Check if the token syntactically closes a block.\n\n  function isBlockFollow(token) {\n    if (EOF === token.type) return true;\n    if (Keyword !== token.type) return false;\n    switch (token.value) {\n      case 'else': case 'elseif':\n      case 'end': case 'until':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // Scope\n  // -----\n\n  // Store each block scope as a an array of identifier names. Each scope is\n  // stored in an FILO-array.\n  var scopes\n    // The current scope index\n    , scopeDepth\n    // A list of all global identifier nodes.\n    , globals;\n\n  // Create a new scope inheriting all declarations from the previous scope.\n  function createScope() {\n    var scope = scopes[scopeDepth++].slice();\n    scopes.push(scope);\n    if (options.onCreateScope) options.onCreateScope();\n  }\n\n  // Exit and remove the current scope.\n  function destroyScope() {\n    var scope = scopes.pop();\n    --scopeDepth;\n    if (options.onDestroyScope) options.onDestroyScope();\n  }\n\n  // Add identifier name to the current scope if it doesnt already exist.\n  function scopeIdentifierName(name) {\n    if (options.onLocalDeclaration) options.onLocalDeclaration(name);\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n    scopes[scopeDepth].push(name);\n  }\n\n  // Add identifier to the current scope\n  function scopeIdentifier(node) {\n    scopeIdentifierName(node.name);\n    attachScope(node, true);\n  }\n\n  // Attach scope information to node. If the node is global, store it in the\n  // globals array so we can return the information to the user.\n  function attachScope(node, isLocal) {\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\n      globals.push(node);\n\n    node.isLocal = isLocal;\n  }\n\n  // Is the identifier name available in this scope.\n  function scopeHasName(name) {\n    return (-1 !== indexOf(scopes[scopeDepth], name));\n  }\n\n  // Location tracking\n  // -----------------\n  //\n  // Locations are stored in FILO-array as a `Marker` object consisting of both\n  // `loc` and `range` data. Once a `Marker` is popped off the list an end\n  // location is added and the data is attached to a syntax node.\n\n  var locations = []\n    , trackLocations;\n\n  function createLocationMarker() {\n    return new Marker(token);\n  }\n\n  function Marker(token) {\n    if (options.locations) {\n      this.loc = {\n          start: {\n            line: token.line\n          , column: token.range[0] - token.lineStart\n        }\n        , end: {\n            line: 0\n          , column: 0\n        }\n      };\n    }\n    if (options.ranges) this.range = [token.range[0], 0];\n  }\n\n  // Complete the location data stored in the `Marker` by adding the location\n  // of the *previous token* as an end location.\n  Marker.prototype.complete = function() {\n    if (options.locations) {\n      this.loc.end.line = previousToken.lastLine || previousToken.line;\n      this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);\n    }\n    if (options.ranges) {\n      this.range[1] = previousToken.range[1];\n    }\n  };\n\n  Marker.prototype.bless = function (node) {\n    if (this.loc) {\n      var loc = this.loc;\n      node.loc = {\n        start: {\n          line: loc.start.line,\n          column: loc.start.column\n        },\n        end: {\n          line: loc.end.line,\n          column: loc.end.column\n        }\n      };\n    }\n    if (this.range) {\n      node.range = [\n        this.range[0],\n        this.range[1]\n      ];\n    }\n  };\n\n  // Create a new `Marker` and add it to the FILO-array.\n  function markLocation() {\n    if (trackLocations) locations.push(createLocationMarker());\n  }\n\n  // Push an arbitrary `Marker` object onto the FILO-array.\n  function pushLocation(marker) {\n    if (trackLocations) locations.push(marker);\n  }\n\n  // Control flow tracking\n  // ---------------------\n  // A context object that validates loop breaks and `goto`-based control flow.\n\n  function FullFlowContext() {\n    this.scopes = [];\n    this.pendingGotos = [];\n  }\n\n  FullFlowContext.prototype.isInLoop = function () {\n    var i = this.scopes.length;\n    while (i --> 0) {\n      if (this.scopes[i].isLoop)\n        return true;\n    }\n    return false;\n  };\n\n  FullFlowContext.prototype.pushScope = function (isLoop) {\n    var scope = {\n      labels: {},\n      locals: [],\n      deferredGotos: [],\n      isLoop: !!isLoop\n    };\n    this.scopes.push(scope);\n  };\n\n  FullFlowContext.prototype.popScope = function () {\n    for (var i = 0; i < this.pendingGotos.length; ++i) {\n      var theGoto = this.pendingGotos[i];\n      if (theGoto.maxDepth >= this.scopes.length)\n        if (--theGoto.maxDepth <= 0)\n          raise(theGoto.token, errors.labelNotVisible, theGoto.target);\n    }\n\n    this.scopes.pop();\n  };\n\n  FullFlowContext.prototype.addGoto = function (target, token) {\n    var localCounts = [];\n\n    for (var i = 0; i < this.scopes.length; ++i) {\n      var scope = this.scopes[i];\n      localCounts.push(scope.locals.length);\n      if (Object.prototype.hasOwnProperty.call(scope.labels, target))\n        return;\n    }\n\n    this.pendingGotos.push({\n      maxDepth: this.scopes.length,\n      target: target,\n      token: token,\n      localCounts: localCounts\n    });\n  };\n\n  FullFlowContext.prototype.addLabel = function (name, token) {\n    var scope = this.currentScope();\n\n    if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {\n      raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);\n    } else {\n      var newGotos = [];\n\n      for (var i = 0; i < this.pendingGotos.length; ++i) {\n        var theGoto = this.pendingGotos[i];\n\n        if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {\n          if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {\n            scope.deferredGotos.push(theGoto);\n          }\n          continue;\n        }\n\n        newGotos.push(theGoto);\n      }\n\n      this.pendingGotos = newGotos;\n    }\n\n    scope.labels[name] = {\n      localCount: scope.locals.length,\n      line: token.line\n    };\n  };\n\n  FullFlowContext.prototype.addLocal = function (name, token) {\n    this.currentScope().locals.push({\n      name: name,\n      token: token\n    });\n  };\n\n  FullFlowContext.prototype.currentScope = function () {\n    return this.scopes[this.scopes.length - 1];\n  };\n\n  FullFlowContext.prototype.raiseDeferredErrors = function () {\n    var scope = this.currentScope();\n    var bads = scope.deferredGotos;\n    for (var i = 0; i < bads.length; ++i) {\n      var theGoto = bads[i];\n      raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);\n    }\n    // Would be dead code currently, but may be useful later\n    // if (bads.length)\n    //   scope.deferredGotos = [];\n  };\n\n  // Simplified context that only checks the validity of loop breaks.\n\n  function LoopFlowContext() {\n    this.level = 0;\n    this.loopLevels = [];\n  }\n\n  LoopFlowContext.prototype.isInLoop = function () {\n    return !!this.loopLevels.length;\n  };\n\n  LoopFlowContext.prototype.pushScope = function (isLoop) {\n    ++this.level;\n    if (isLoop)\n      this.loopLevels.push(this.level);\n  };\n\n  LoopFlowContext.prototype.popScope = function () {\n    var levels = this.loopLevels;\n    var levlen = levels.length;\n    if (levlen) {\n      if (levels[levlen - 1] === this.level)\n        levels.pop();\n    }\n    --this.level;\n  };\n\n  LoopFlowContext.prototype.addGoto =\n  LoopFlowContext.prototype.addLabel =\n  /* istanbul ignore next */\n  function () { throw new Error('This should never happen'); };\n\n  LoopFlowContext.prototype.addLocal =\n  LoopFlowContext.prototype.raiseDeferredErrors =\n  function () {};\n\n  function makeFlowContext() {\n    return features.labels ? new FullFlowContext() : new LoopFlowContext();\n  }\n\n  // Parse functions\n  // ---------------\n\n  // Chunk is the main program object. Syntactically it's the same as a block.\n  //\n  //     chunk ::= block\n\n  function parseChunk() {\n    next();\n    markLocation();\n    if (options.scope) createScope();\n    var flowContext = makeFlowContext();\n    flowContext.allowVararg = true;\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    if (EOF !== token.type) unexpected(token);\n    // If the body is empty no previousToken exists when finishNode runs.\n    if (trackLocations && !body.length) previousToken = token;\n    return finishNode(ast.chunk(body));\n  }\n\n  // A block contains a list of statements with an optional return statement\n  // as its last statement.\n  //\n  //     block ::= {stat} [retstat]\n\n  function parseBlock(flowContext) {\n    var block = []\n      , statement;\n\n    while (!isBlockFollow(token)) {\n      // Return has to be the last statement in a block.\n      // Likewise 'break' in Lua older than 5.2\n      if ('return' === token.value || (!features.relaxedBreak && 'break' === token.value)) {\n        block.push(parseStatement(flowContext));\n        break;\n      }\n      statement = parseStatement(flowContext);\n      consume(';');\n      // Statements are only added if they are returned, this allows us to\n      // ignore some statements, such as EmptyStatement.\n      if (statement) block.push(statement);\n    }\n\n    // Doesn't really need an ast node\n    return block;\n  }\n\n  // There are two types of statements, simple and compound.\n  //\n  //     statement ::= break | goto | do | while | repeat | return\n  //          | if | for | function | local | label | assignment\n  //          | functioncall | ';'\n\n  function parseStatement(flowContext) {\n    markLocation();\n\n    if (Punctuator === token.type) {\n      if (consume('::')) return parseLabelStatement(flowContext);\n    }\n\n    // When a `;` is encounted, simply eat it without storing it.\n    if (features.emptyStatement) {\n      if (consume(';')) {\n        if (trackLocations) locations.pop();\n        return;\n      }\n    }\n\n    flowContext.raiseDeferredErrors();\n\n    if (Keyword === token.type) {\n      switch (token.value) {\n        case 'local':    next(); return parseLocalStatement(flowContext);\n        case 'if':       next(); return parseIfStatement(flowContext);\n        case 'return':   next(); return parseReturnStatement(flowContext);\n        case 'function': next();\n          var name = parseFunctionName();\n          return parseFunctionDeclaration(name);\n        case 'while':    next(); return parseWhileStatement(flowContext);\n        case 'for':      next(); return parseForStatement(flowContext);\n        case 'repeat':   next(); return parseRepeatStatement(flowContext);\n        case 'break':    next();\n          if (!flowContext.isInLoop())\n            raise(token, errors.noLoopToBreak, token.value);\n          return parseBreakStatement();\n        case 'do':       next(); return parseDoStatement(flowContext);\n        case 'goto':     next(); return parseGotoStatement(flowContext);\n      }\n    }\n\n    if (features.contextualGoto &&\n        token.type === Identifier && token.value === 'goto' &&\n        lookahead.type === Identifier && lookahead.value !== 'goto') {\n      next(); return parseGotoStatement(flowContext);\n    }\n\n    // Assignments memorizes the location and pushes it manually for wrapper nodes.\n    if (trackLocations) locations.pop();\n\n    return parseAssignmentOrCallStatement(flowContext);\n  }\n\n  // ## Statements\n\n  //     label ::= '::' Name '::'\n\n  function parseLabelStatement(flowContext) {\n    var nameToken = token\n      , label = parseIdentifier();\n\n    if (options.scope) {\n      scopeIdentifierName('::' + nameToken.value + '::');\n      attachScope(label, true);\n    }\n\n    expect('::');\n\n    flowContext.addLabel(nameToken.value, nameToken);\n    return finishNode(ast.labelStatement(label));\n  }\n\n  //     break ::= 'break'\n\n  function parseBreakStatement() {\n    return finishNode(ast.breakStatement());\n  }\n\n  //     goto ::= 'goto' Name\n\n  function parseGotoStatement(flowContext) {\n    var name = token.value\n      , gotoToken = previousToken\n      , label = parseIdentifier();\n\n    flowContext.addGoto(name, gotoToken);\n    return finishNode(ast.gotoStatement(label));\n  }\n\n  //     do ::= 'do' block 'end'\n\n  function parseDoStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.doStatement(body));\n  }\n\n  //     while ::= 'while' exp 'do' block 'end'\n\n  function parseWhileStatement(flowContext) {\n    var condition = parseExpectedExpression(flowContext);\n    expect('do');\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.whileStatement(condition, body));\n  }\n\n  //     repeat ::= 'repeat' block 'until' exp\n\n  function parseRepeatStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    expect('until');\n    flowContext.raiseDeferredErrors();\n    var condition = parseExpectedExpression(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    return finishNode(ast.repeatStatement(condition, body));\n  }\n\n  //     retstat ::= 'return' [exp {',' exp}] [';']\n\n  function parseReturnStatement(flowContext) {\n    var expressions = [];\n\n    if ('end' !== token.value) {\n      var expression = parseExpression(flowContext);\n      if (null != expression) expressions.push(expression);\n      while (consume(',')) {\n        expression = parseExpectedExpression(flowContext);\n        expressions.push(expression);\n      }\n      consume(';'); // grammar tells us ; is optional here.\n    }\n    return finishNode(ast.returnStatement(expressions));\n  }\n\n  //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'\n  //     elif ::= 'elseif' exp 'then' block\n\n  function parseIfStatement(flowContext) {\n    var clauses = []\n      , condition\n      , body\n      , marker;\n\n    // IfClauses begin at the same location as the parent IfStatement.\n    // It ends at the start of `end`, `else`, or `elseif`.\n    if (trackLocations) {\n      marker = locations[locations.length - 1];\n      locations.push(marker);\n    }\n    condition = parseExpectedExpression(flowContext);\n    expect('then');\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    clauses.push(finishNode(ast.ifClause(condition, body)));\n\n    if (trackLocations) marker = createLocationMarker();\n    while (consume('elseif')) {\n      pushLocation(marker);\n      condition = parseExpectedExpression(flowContext);\n      expect('then');\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n    }\n\n    if (consume('else')) {\n      // Include the `else` in the location of ElseClause.\n      if (trackLocations) {\n        marker = new Marker(previousToken);\n        locations.push(marker);\n      }\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseClause(body)));\n    }\n\n    expect('end');\n    return finishNode(ast.ifStatement(clauses));\n  }\n\n  // There are two types of for statements, generic and numeric.\n  //\n  //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'\n  //     for ::= namelist 'in' explist 'do' block 'end'\n  //     namelist ::= Name {',' Name}\n  //     explist ::= exp {',' exp}\n\n  function parseForStatement(flowContext) {\n    var variable = parseIdentifier()\n      , body;\n\n    // The start-identifier is local.\n\n    if (options.scope) {\n      createScope();\n      scopeIdentifier(variable);\n    }\n\n    // If the first expression is followed by a `=` punctuator, this is a\n    // Numeric For Statement.\n    if (consume('=')) {\n      // Start expression\n      var start = parseExpectedExpression(flowContext);\n      expect(',');\n      // End expression\n      var end = parseExpectedExpression(flowContext);\n      // Optional step expression\n      var step = consume(',') ? parseExpectedExpression(flowContext) : null;\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n    }\n    // If not, it's a Generic For Statement\n    else {\n      // The namelist can contain one or more identifiers.\n      var variables = [variable];\n      while (consume(',')) {\n        variable = parseIdentifier();\n        // Each variable in the namelist is locally scoped.\n        if (options.scope) scopeIdentifier(variable);\n        variables.push(variable);\n      }\n      expect('in');\n      var iterators = [];\n\n      // One or more expressions in the explist.\n      do {\n        var expression = parseExpectedExpression(flowContext);\n        iterators.push(expression);\n      } while (consume(','));\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\n    }\n  }\n\n  // Local statements can either be variable assignments or function\n  // definitions. If a function definition is found, it will be delegated to\n  // `parseFunctionDeclaration()` with the isLocal flag.\n  //\n  // This AST structure might change into a local assignment with a function\n  // child.\n  //\n  //     local ::= 'local' 'function' Name funcdecl\n  //        | 'local' Name {',' Name} ['=' exp {',' exp}]\n\n  function parseLocalStatement(flowContext) {\n    var name\n      , declToken = previousToken;\n\n    if (Identifier === token.type) {\n      var variables = []\n        , init = [];\n\n      do {\n        name = parseIdentifier();\n\n        variables.push(name);\n        flowContext.addLocal(name.name, declToken);\n      } while (consume(','));\n\n      if (consume('=')) {\n        do {\n          var expression = parseExpectedExpression(flowContext);\n          init.push(expression);\n        } while (consume(','));\n      }\n\n      // Declarations doesn't exist before the statement has been evaluated.\n      // Therefore assignments can't use their declarator. And the identifiers\n      // shouldn't be added to the scope until the statement is complete.\n      if (options.scope) {\n        for (var i = 0, l = variables.length; i < l; ++i) {\n          scopeIdentifier(variables[i]);\n        }\n      }\n\n      return finishNode(ast.localStatement(variables, init));\n    }\n    if (consume('function')) {\n      name = parseIdentifier();\n      flowContext.addLocal(name.name, declToken);\n\n      if (options.scope) {\n        scopeIdentifier(name);\n        createScope();\n      }\n\n      // MemberExpressions are not allowed in local function statements.\n      return parseFunctionDeclaration(name, true);\n    } else {\n      raiseUnexpectedToken('<name>', token);\n    }\n  }\n\n  //     assignment ::= varlist '=' explist\n  //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name\n  //     varlist ::= var {',' var}\n  //     explist ::= exp {',' exp}\n  //\n  //     call ::= callexp\n  //     callexp ::= prefixexp args | prefixexp ':' Name args\n\n  function parseAssignmentOrCallStatement(flowContext) {\n    // Keep a reference to the previous token for better error messages in case\n    // of invalid statement\n    var previous = token\n      , marker, startMarker;\n    var lvalue, base, name;\n\n    var targets = [];\n\n    if (trackLocations) startMarker = createLocationMarker();\n\n    do {\n      if (trackLocations) marker = createLocationMarker();\n\n      if (Identifier === token.type) {\n        name = token.value;\n        base = parseIdentifier();\n        // Set the parent scope.\n        if (options.scope) attachScope(base, scopeHasName(name));\n        lvalue = true;\n      } else if ('(' === token.value) {\n        next();\n        base = parseExpectedExpression(flowContext);\n        expect(')');\n        lvalue = false;\n      } else {\n        return unexpected(token);\n      }\n\n      both: for (;;) {\n        var newBase;\n\n        switch (StringLiteral === token.type ? '\"' : token.value) {\n        case '.':\n        case '[':\n          lvalue = true;\n          break;\n        case ':':\n        case '(':\n        case '{':\n        case '\"':\n          lvalue = null;\n          break;\n        default:\n          break both;\n        }\n\n        base = parsePrefixExpressionPart(base, marker, flowContext);\n      }\n\n      targets.push(base);\n\n      if (',' !== token.value)\n        break;\n\n      if (!lvalue) {\n        return unexpected(token);\n      }\n\n      next();\n    } while (true);\n\n    if (targets.length === 1 && lvalue === null) {\n      pushLocation(marker);\n      return finishNode(ast.callStatement(targets[0]));\n    } else if (!lvalue) {\n      return unexpected(token);\n    }\n\n    expect('=');\n\n    var values = [];\n\n    do {\n      values.push(parseExpectedExpression(flowContext));\n    } while (consume(','));\n\n    pushLocation(startMarker);\n    return finishNode(ast.assignmentStatement(targets, values));\n  }\n\n  // ### Non-statements\n\n  //     Identifier ::= Name\n\n  function parseIdentifier() {\n    markLocation();\n    var identifier = token.value;\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n    next();\n    return finishNode(ast.identifier(identifier));\n  }\n\n  // Parse the functions parameters and body block. The name should already\n  // have been parsed and passed to this declaration function. By separating\n  // this we allow for anonymous functions in expressions.\n  //\n  // For local functions there's a boolean parameter which needs to be set\n  // when parsing the declaration.\n  //\n  //     funcdecl ::= '(' [parlist] ')' block 'end'\n  //     parlist ::= Name {',' Name} | [',' '...'] | '...'\n\n  function parseFunctionDeclaration(name, isLocal) {\n    var flowContext = makeFlowContext();\n    flowContext.pushScope();\n\n    var parameters = [];\n    expect('(');\n\n    // The declaration has arguments\n    if (!consume(')')) {\n      // Arguments are a comma separated list of identifiers, optionally ending\n      // with a vararg.\n      while (true) {\n        if (Identifier === token.type) {\n          var parameter = parseIdentifier();\n          // Function parameters are local.\n          if (options.scope) scopeIdentifier(parameter);\n\n          parameters.push(parameter);\n\n          if (consume(',')) continue;\n        }\n        // No arguments are allowed after a vararg.\n        else if (VarargLiteral === token.type) {\n          flowContext.allowVararg = true;\n          parameters.push(parsePrimaryExpression(flowContext));\n        } else {\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\n        }\n        expect(')');\n        break;\n      }\n    }\n\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    expect('end');\n    if (options.scope) destroyScope();\n\n    isLocal = isLocal || false;\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n  }\n\n  // Parse the function name as identifiers and member expressions.\n  //\n  //     Name {'.' Name} [':' Name]\n\n  function parseFunctionName() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    base = parseIdentifier();\n\n    if (options.scope) {\n      attachScope(base, scopeHasName(base.name));\n      createScope();\n    }\n\n    while (consume('.')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, '.', name));\n    }\n\n    if (consume(':')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, ':', name));\n      if (options.scope) scopeIdentifierName('self');\n    }\n\n    return base;\n  }\n\n  //     tableconstructor ::= '{' [fieldlist] '}'\n  //     fieldlist ::= field {fieldsep field} fieldsep\n  //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp\n  //\n  //     fieldsep ::= ',' | ';'\n\n  function parseTableConstructor(flowContext) {\n    var fields = []\n      , key, value;\n\n    while (true) {\n      markLocation();\n      if (Punctuator === token.type && consume('[')) {\n        key = parseExpectedExpression(flowContext);\n        expect(']');\n        expect('=');\n        value = parseExpectedExpression(flowContext);\n        fields.push(finishNode(ast.tableKey(key, value)));\n      } else if (Identifier === token.type) {\n        if ('=' === lookahead.value) {\n          key = parseIdentifier();\n          next();\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableKeyString(key, value)));\n        } else {\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n      } else {\n        if (null == (value = parseExpression(flowContext))) {\n          locations.pop();\n          break;\n        }\n        fields.push(finishNode(ast.tableValue(value)));\n      }\n      if (',;'.indexOf(token.value) >= 0) {\n        next();\n        continue;\n      }\n      break;\n    }\n    expect('}');\n    return finishNode(ast.tableConstructorExpression(fields));\n  }\n\n  // Expression parser\n  // -----------------\n  //\n  // Expressions are evaluated and always return a value. If nothing is\n  // matched null will be returned.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n  //\n  //     primary ::= nil | false | true | Number | String | '...'\n  //          | functiondef | tableconstructor\n  //\n  //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'\n  //          | '.' Name | ':' Name args | args }\n  //\n\n  function parseExpression(flowContext) {\n    var expression = parseSubExpression(0, flowContext);\n    return expression;\n  }\n\n  // Parse an expression expecting it to be valid.\n\n  function parseExpectedExpression(flowContext) {\n    var expression = parseExpression(flowContext);\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\n    else return expression;\n  }\n\n\n  // Return the precedence priority of the operator.\n  //\n  // As unary `-` can't be distinguished from binary `-`, unary precedence\n  // isn't described in this table but in `parseSubExpression()` itself.\n  //\n  // As this function gets hit on every expression it's been optimized due to\n  // the expensive CompareICStub which took ~8% of the parse time.\n\n  function binaryPrecedence(operator) {\n    var charCode = operator.charCodeAt(0)\n      , length = operator.length;\n\n    if (1 === length) {\n      switch (charCode) {\n        case 94: return 12; // ^\n        case 42: case 47: case 37: return 10; // * / %\n        case 43: case 45: return 9; // + -\n        case 38: return 6; // &\n        case 126: return 5; // ~\n        case 124: return 4; // |\n        case 60: case 62: return 3; // < >\n      }\n    } else if (2 === length) {\n      switch (charCode) {\n        case 47: return 10; // //\n        case 46: return 8; // ..\n        case 60: case 62:\n            if('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3; // <= >=\n        case 61: case 126: return 3; // == ~=\n        case 111: return 1; // or\n      }\n    } else if (97 === charCode && 'and' === operator) return 2;\n    return 0;\n  }\n\n  // Implement an operator-precedence parser to handle binary operator\n  // precedence.\n  //\n  // We use this algorithm because it's compact, it's fast and Lua core uses\n  // the same so we can be sure our expressions are parsed in the same manner\n  // without excessive amounts of tests.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n\n  function parseSubExpression(minPrecedence, flowContext) {\n    var operator = token.value\n    // The left-hand side in binary operations.\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // UnaryExpression\n    if (isUnary(token)) {\n      markLocation();\n      next();\n      var argument = parseSubExpression(10, flowContext);\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\n      expression = finishNode(ast.unaryExpression(operator, argument));\n    }\n    if (null == expression) {\n      // PrimaryExpression\n      expression = parsePrimaryExpression(flowContext);\n\n      // PrefixExpression\n      if (null == expression) {\n        expression = parsePrefixExpression(flowContext);\n      }\n    }\n    // This is not a valid left hand expression.\n    if (null == expression) return null;\n\n    var precedence;\n    while (true) {\n      operator = token.value;\n\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\n        binaryPrecedence(operator) : 0;\n\n      if (precedence === 0 || precedence <= minPrecedence) break;\n      // Right-hand precedence operators\n      if ('^' === operator || '..' === operator) --precedence;\n      next();\n      var right = parseSubExpression(precedence, flowContext);\n      if (null == right) raiseUnexpectedToken('<expression>', token);\n      // Push in the marker created before the loop to wrap its entirety.\n      if (trackLocations) locations.push(marker);\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\n\n    }\n    return expression;\n  }\n\n  //     prefixexp ::= prefix {suffix}\n  //     prefix ::= Name | '(' exp ')'\n  //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args\n  //\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parsePrefixExpressionPart(base, marker, flowContext) {\n    var expression, identifier;\n\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '[':\n          pushLocation(marker);\n          next();\n          expression = parseExpectedExpression(flowContext);\n          expect(']');\n          return finishNode(ast.indexExpression(base, expression));\n        case '.':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          return finishNode(ast.memberExpression(base, '.', identifier));\n        case ':':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          base = finishNode(ast.memberExpression(base, ':', identifier));\n          // Once a : is found, this has to be a CallExpression, otherwise\n          // throw an error.\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n        case '(': case '{': // args\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n      }\n    } else if (StringLiteral === token.type) {\n      pushLocation(marker);\n      return parseCallExpression(base, flowContext);\n    }\n\n    return null;\n  }\n\n  function parsePrefixExpression(flowContext) {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // The prefix\n    if (Identifier === token.type) {\n      name = token.value;\n      base = parseIdentifier();\n      // Set the parent scope.\n      if (options.scope) attachScope(base, scopeHasName(name));\n    } else if (consume('(')) {\n      base = parseExpectedExpression(flowContext);\n      expect(')');\n    } else {\n      return null;\n    }\n\n    // The suffix\n    for (;;) {\n      var newBase = parsePrefixExpressionPart(base, marker, flowContext);\n      if (newBase === null)\n        break;\n      base = newBase;\n    }\n\n    return base;\n  }\n\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parseCallExpression(base, flowContext) {\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '(':\n          if (!features.emptyStatement) {\n            if (token.line !== previousToken.line)\n              raise(null, errors.ambiguousSyntax, token.value);\n          }\n          next();\n\n          // List of expressions\n          var expressions = [];\n          var expression = parseExpression(flowContext);\n          if (null != expression) expressions.push(expression);\n          while (consume(',')) {\n            expression = parseExpectedExpression(flowContext);\n            expressions.push(expression);\n          }\n\n          expect(')');\n          return finishNode(ast.callExpression(base, expressions));\n\n        case '{':\n          markLocation();\n          next();\n          var table = parseTableConstructor(flowContext);\n          return finishNode(ast.tableCallExpression(base, table));\n      }\n    } else if (StringLiteral === token.type) {\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));\n    }\n\n    raiseUnexpectedToken('function arguments', token);\n  }\n\n  //     primary ::= String | Numeric | nil | true | false\n  //          | functiondef | tableconstructor | '...'\n\n  function parsePrimaryExpression(flowContext) {\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\n      , value = token.value\n      , type = token.type\n      , marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    if (type === VarargLiteral && !flowContext.allowVararg) {\n      raise(token, errors.cannotUseVararg, token.value);\n    }\n\n    if (type & literals) {\n      pushLocation(marker);\n      var raw = input.slice(token.range[0], token.range[1]);\n      next();\n      return finishNode(ast.literal(type, value, raw));\n    } else if (Keyword === type && 'function' === value) {\n      pushLocation(marker);\n      next();\n      if (options.scope) createScope();\n      return parseFunctionDeclaration(null);\n    } else if (consume('{')) {\n      pushLocation(marker);\n      return parseTableConstructor(flowContext);\n    }\n  }\n\n  // Parser\n  // ------\n\n  // Export the main parser.\n  //\n  //   - `wait` Hold parsing until end() is called. Defaults to false\n  //   - `comments` Store comments. Defaults to true.\n  //   - `scope` Track identifier scope. Defaults to false.\n  //   - `locations` Store location information. Defaults to false.\n  //   - `ranges` Store the start and end character locations. Defaults to\n  //     false.\n  //   - `onCreateNode` Callback which will be invoked when a syntax node is\n  //     created.\n  //   - `onCreateScope` Callback which will be invoked when a new scope is\n  //     created.\n  //   - `onDestroyScope` Callback which will be invoked when the current scope\n  //     is destroyed.\n  //\n  // Example:\n  //\n  //     var parser = require('luaparser');\n  //     parser.parse('i = 0');\n\n  exports.parse = parse;\n\n  var versionFeatures = {\n    '5.1': {\n    },\n    '5.2': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      relaxedBreak: true\n    },\n    '5.3': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      bitwiseOperators: true,\n      integerDivision: true,\n      relaxedBreak: true\n    },\n    'LuaJIT': {\n      // XXX: LuaJIT language features may depend on compilation options; may need to\n      // rethink how to handle this. Specifically, there is a LUAJIT_ENABLE_LUA52COMPAT\n      // that removes contextual goto. Maybe add 'LuaJIT-5.2compat' as well?\n      labels: true,\n      contextualGoto: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      imaginaryNumbers: true,\n      integerSuffixes: true\n    }\n  };\n\n  function parse(_input, _options) {\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\n      _options = _input;\n      _input = undefined;\n    }\n    if (!_options) _options = {};\n\n    input = _input || '';\n    options = assign({}, defaultOptions, _options);\n\n    // Rewind the lexer\n    index = 0;\n    line = 1;\n    lineStart = 0;\n    length = input.length;\n    // When tracking identifier scope, initialize with an empty scope.\n    scopes = [[]];\n    scopeDepth = 0;\n    globals = [];\n    locations = [];\n\n    if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {\n      throw new Error(sprintf(\"Lua version '%1' not supported\", options.luaVersion));\n    }\n\n    features = assign({}, versionFeatures[options.luaVersion]);\n    if (options.extendedIdentifiers !== void 0)\n      features.extendedIdentifiers = !!options.extendedIdentifiers;\n\n    if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {\n      throw new Error(sprintf(\"Encoding mode '%1' not supported\", options.encodingMode));\n    }\n\n    encodingMode = encodingModes[options.encodingMode];\n\n    if (options.comments) comments = [];\n    if (!options.wait) return end();\n    return exports;\n  }\n\n  // Write to the source code buffer without beginning the parse.\n  exports.write = write;\n\n  function write(_input) {\n    input += String(_input);\n    length = input.length;\n    return exports;\n  }\n\n  // Send an EOF and begin parsing.\n  exports.end = end;\n\n  function end(_input) {\n    if ('undefined' !== typeof _input) write(_input);\n\n    // Ignore shebangs.\n    if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n      return line.replace(/./g, ' ');\n    });\n\n    length = input.length;\n    trackLocations = options.locations || options.ranges;\n    // Initialize with a lookahead token.\n    lookahead = lex();\n\n    var chunk = parseChunk();\n    if (options.comments) chunk.comments = comments;\n    if (options.scope) chunk.globals = globals;\n\n    /* istanbul ignore if */\n    if (locations.length > 0)\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n\n    return chunk;\n  }\n\n}));\n/* vim: set sw=2 ts=2 et tw=79 : */\n", "import luaparse from 'luaparse';\r\n\r\nconst fandomModules = {\r\n  Lawnames: \"Lawnames\",\r\n  Flagdata: \"Flagdata\",\r\n  Nationdata: \"Nationdata\",\r\n  Tagdata: \"Tagdata\"\r\n}\r\n\r\n// Cache for resolved file URLs\r\nconst fileUrlCache = {};\r\n\r\n// Resolve Fandom file references to actual image URLs\r\nexport async function resolveFileUrl(fileReference) {\r\n  if (!fileReference) {\r\n    return fileReference;\r\n  }\r\n  \r\n  if (fileUrlCache[fileReference]) {\r\n    return fileUrlCache[fileReference];\r\n  }\r\n\r\n  try {\r\n    const response = await fetch(`/api/resolve-file?file=${encodeURIComponent(fileReference)}`);\r\n    const data = await response.json();\r\n    \r\n    if (data.url) {\r\n      fileUrlCache[fileReference] = data.url;\r\n      return data.url;\r\n    }\r\n  } catch (error) {\r\n    console.error(`Error resolving file ${fileReference}:`, error);\r\n  }\r\n  \r\n  return fileReference;\r\n}\r\n\r\n// fetch lua modules directly from fandom\r\nasync function loadAllModules() {\r\n  const modulePromises = Object.entries(fandomModules).map(async ([name, moduleName]) => {\r\n    const url = `https://ronroblox.fandom.com/rest.php/v1/page/Module%3A${moduleName}`;\r\n    try {\r\n      const response = await fetch(url);\r\n      const data = await response.json();\r\n      return [name, data.source];\r\n    } catch (error) {\r\n      console.error(`Error fetching ${name}:`, error);\r\n      throw error;\r\n    }\r\n  });\r\n\r\n  const moduleEntries = await Promise.all(modulePromises);\r\n  return Object.fromEntries(moduleEntries);\r\n}\r\n\r\n// Recursively extract values from AST nodes\r\nasync function extractValue(node) {\r\n  if (!node) return null;\r\n\r\n  switch (node.type) {\r\n    case 'StringLiteral':\r\n      // Handle both value and raw (quoted string)\r\n      let stringValue = null;\r\n      if (node.value !== null) stringValue = node.value;\r\n      else if (node.raw) {\r\n        stringValue = node.raw.slice(1, -1);\r\n      }\r\n\r\n      // Resolve file URLs\r\n      if (stringValue?.startsWith('File:')) {\r\n        return await resolveFileUrl(stringValue);\r\n      }\r\n      return stringValue;\r\n\r\n    case 'NumericLiteral':\r\n      return node.value;\r\n\r\n    case 'BooleanLiteral':\r\n      return node.value;\r\n\r\n    case 'NilLiteral':\r\n      return null;\r\n\r\n    case 'BinaryExpression':\r\n      const left = await extractValue(node.left);\r\n      const right = await extractValue(node.right);\r\n\r\n      if (typeof left === 'number' && typeof right === 'number') {\r\n        switch (node.operator) {\r\n          case '+': return left + right;\r\n          case '-': return left - right;\r\n          case '*': return left * right;\r\n          case '/': return left / right;\r\n          case '%': return left % right;\r\n          case '^': return Math.pow(left, right);\r\n          default: return null;\r\n        }\r\n      }\r\n      return null;\r\n\r\n    case 'TableConstructorExpression':\r\n      return await extractTable(node);\r\n\r\n    default:\r\n      return null;\r\n  }\r\n}\r\n\r\n// Convert table constructor to JS object/array\r\nasync function extractTable(tableNode) {\r\n  const obj = {};\r\n\r\n  for (const field of tableNode.fields) {\r\n    let key, value;\r\n\r\n    if (field.type === 'TableKey') {\r\n      key = await extractValue(field.key);\r\n      value = await extractValue(field.value);\r\n      obj[key] = value;\r\n    } else if (field.type === 'TableKeyString') {\r\n      key = field.key.name;\r\n      value = await extractValue(field.value);\r\n      obj[key] = value;\r\n    } else if (field.type === 'TableValue') {\r\n      obj[tableNode.fields.indexOf(field) + 1] = await extractValue(field.value);\r\n    }\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\n// Export the extracted data\r\nexport async function getFandomData() {\r\n  const allModules = await loadAllModules();\r\n  const extractedData = {};\r\n\r\n  for (const [name, source] of Object.entries(allModules)) {\r\n    try {\r\n      const ast = luaparse.parse(source);\r\n      extractedData[name] = await extractDataFromAST(ast);\r\n    } catch (error) {\r\n      console.error(`Error parsing ${name}:`, error);\r\n    }\r\n  }\r\n\r\n  return extractedData;\r\n}\r\n\r\n// Function to convert Lua AST to usable data\r\nasync function extractDataFromAST(ast) {\r\n  const result = {};\r\n\r\n  for (const statement of ast.body) {\r\n    if (statement.type === 'AssignmentStatement' || statement.type === 'LocalStatement') {\r\n      const varName = statement.variables[0].name;\r\n      const value = await extractValue(statement.init[0]);\r\n      result[varName] = value;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n", "import { getFandomData } from '../../fandomProcessor.js';\r\n\r\nlet cachedFandomData = null;\r\nlet cacheTime = null;\r\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\r\n\r\nexport async function onRequest(context) {\r\n  try {\r\n    // Return cached data if fresh\r\n    if (cachedFandomData && cacheTime && Date.now() - cacheTime < CACHE_DURATION) {\r\n      return new Response(JSON.stringify(cachedFandomData), {\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Access-Control-Allow-Origin': '*'\r\n        }\r\n      });\r\n    }\r\n\r\n    // Fetch fresh data\r\n    cachedFandomData = await getFandomData();\r\n    cacheTime = Date.now();\r\n\r\n    return new Response(JSON.stringify(cachedFandomData), {\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Access-Control-Allow-Origin': '*'\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Error in fandom-data endpoint:', error);\r\n    return new Response(JSON.stringify({ error: error.message }), {\r\n      status: 500,\r\n      headers: { \r\n        'Content-Type': 'application/json',\r\n        'Access-Control-Allow-Origin': '*'\r\n      }\r\n    });\r\n  }\r\n}", "import { onRequest as __api_fandom_data_js_onRequest } from \"C:\\\\Users\\\\asus\\\\OneDrive\\\\Desktop\\\\Projects\\\\Dyn-Flagger\\\\functions\\\\api\\\\fandom-data.js\"\n\nexport const routes = [\n    {\n      routePath: \"/api/fandom-data\",\n      mountPath: \"/api\",\n      method: \"\",\n      middlewares: [],\n      modules: [__api_fandom_data_js_onRequest],\n    },\n  ]", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"C:\\\\Users\\\\asus\\\\OneDrive\\\\Desktop\\\\Projects\\\\Dyn-Flagger\\\\.wrangler\\\\tmp\\\\bundle-Ugahcn\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"C:\\\\Users\\\\asus\\\\OneDrive\\\\Desktop\\\\Projects\\\\Dyn-Flagger\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"C:\\\\Users\\\\asus\\\\OneDrive\\\\Desktop\\\\Projects\\\\Dyn-Flagger\\\\.wrangler\\\\tmp\\\\bundle-Ugahcn\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"C:\\\\Users\\\\asus\\\\OneDrive\\\\Desktop\\\\Projects\\\\Dyn-Flagger\\\\.wrangler\\\\tmp\\\\bundle-Ugahcn\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"C:\\\\Users\\\\asus\\\\OneDrive\\\\Desktop\\\\Projects\\\\Dyn-Flagger\\\\node_modules\\\\wrangler\\\\templates\\\\pages-template-worker.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"C:\\\\Users\\\\asus\\\\OneDrive\\\\Desktop\\\\Projects\\\\Dyn-Flagger\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"C:\\\\Users\\\\asus\\\\OneDrive\\\\Desktop\\\\Projects\\\\Dyn-Flagger\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"C:\\\\Users\\\\asus\\\\OneDrive\\\\Desktop\\\\Projects\\\\Dyn-Flagger\\\\node_modules\\\\wrangler\\\\templates\\\\pages-template-worker.ts\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "import { match } from \"path-to-regexp\";\n\n//note: this explicitly does not include the * character, as pages requires this\nconst escapeRegex = /[.+?^${}()|[\\]\\\\]/g;\n\ntype HTTPMethod =\n\t| \"HEAD\"\n\t| \"OPTIONS\"\n\t| \"GET\"\n\t| \"POST\"\n\t| \"PUT\"\n\t| \"PATCH\"\n\t| \"DELETE\";\n\n/* TODO: Grab these from @cloudflare/workers-types instead */\ntype Params<P extends string = string> = Record<P, string | string[]>;\n\ntype EventContext<Env, P extends string, Data> = {\n\trequest: Request;\n\tfunctionPath: string;\n\twaitUntil: (promise: Promise<unknown>) => void;\n\tpassThroughOnException: () => void;\n\tnext: (input?: Request | string, init?: RequestInit) => Promise<Response>;\n\tenv: Env & { ASSETS: { fetch: typeof fetch } };\n\tparams: Params<P>;\n\tdata: Data;\n};\n\ndeclare type PagesFunction<\n\tEnv = unknown,\n\tP extends string = string,\n\tData extends Record<string, unknown> = Record<string, unknown>,\n> = (context: EventContext<Env, P, Data>) => Response | Promise<Response>;\n/* end @cloudflare/workers-types */\n\ntype RouteHandler = {\n\troutePath: string;\n\tmountPath: string;\n\tmethod?: HTTPMethod;\n\tmodules: PagesFunction[];\n\tmiddlewares: PagesFunction[];\n};\n\n// inject `routes` via ESBuild\ndeclare const routes: RouteHandler[];\n// define `__FALLBACK_SERVICE__` via ESBuild\ndeclare const __FALLBACK_SERVICE__: string;\n\n// expect an ASSETS fetcher binding pointing to the asset-server stage\ntype FetchEnv = {\n\t[name: string]: { fetch: typeof fetch };\n\tASSETS: { fetch: typeof fetch };\n};\n\ntype WorkerContext = {\n\twaitUntil: (promise: Promise<unknown>) => void;\n\tpassThroughOnException: () => void;\n};\n\nfunction* executeRequest(request: Request) {\n\tconst requestPath = new URL(request.url).pathname;\n\n\t// First, iterate through the routes (backwards) and execute \"middlewares\" on partial route matches\n\tfor (const route of [...routes].reverse()) {\n\t\tif (route.method && route.method !== request.method) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replaces with \"\\\\$&\", this prepends a backslash to the matched string, e.g. \"[\" becomes \"\\[\"\n\t\tconst routeMatcher = match(route.routePath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: false,\n\t\t});\n\t\tconst mountMatcher = match(route.mountPath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: false,\n\t\t});\n\t\tconst matchResult = routeMatcher(requestPath);\n\t\tconst mountMatchResult = mountMatcher(requestPath);\n\t\tif (matchResult && mountMatchResult) {\n\t\t\tfor (const handler of route.middlewares.flat()) {\n\t\t\t\tyield {\n\t\t\t\t\thandler,\n\t\t\t\t\tparams: matchResult.params as Params,\n\t\t\t\t\tpath: mountMatchResult.path,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t// Then look for the first exact route match and execute its \"modules\"\n\tfor (const route of routes) {\n\t\tif (route.method && route.method !== request.method) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst routeMatcher = match(route.routePath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: true,\n\t\t});\n\t\tconst mountMatcher = match(route.mountPath.replace(escapeRegex, \"\\\\$&\"), {\n\t\t\tend: false,\n\t\t});\n\t\tconst matchResult = routeMatcher(requestPath);\n\t\tconst mountMatchResult = mountMatcher(requestPath);\n\t\tif (matchResult && mountMatchResult && route.modules.length) {\n\t\t\tfor (const handler of route.modules.flat()) {\n\t\t\t\tyield {\n\t\t\t\t\thandler,\n\t\t\t\t\tparams: matchResult.params as Params,\n\t\t\t\t\tpath: matchResult.path,\n\t\t\t\t};\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport default {\n\tasync fetch(\n\t\toriginalRequest: Request,\n\t\tenv: FetchEnv,\n\t\tworkerContext: WorkerContext\n\t) {\n\t\tlet request = originalRequest;\n\t\tconst handlerIterator = executeRequest(request);\n\t\tlet data = {}; // arbitrary data the user can set between functions\n\t\tlet isFailOpen = false;\n\n\t\tconst next = async (input?: RequestInfo, init?: RequestInit) => {\n\t\t\tif (input !== undefined) {\n\t\t\t\tlet url = input;\n\t\t\t\tif (typeof input === \"string\") {\n\t\t\t\t\turl = new URL(input, request.url).toString();\n\t\t\t\t}\n\t\t\t\trequest = new Request(url, init);\n\t\t\t}\n\n\t\t\tconst result = handlerIterator.next();\n\t\t\t// Note we can't use `!result.done` because this doesn't narrow to the correct type\n\t\t\tif (result.done === false) {\n\t\t\t\tconst { handler, params, path } = result.value;\n\t\t\t\tconst context = {\n\t\t\t\t\trequest: new Request(request.clone()),\n\t\t\t\t\tfunctionPath: path,\n\t\t\t\t\tnext,\n\t\t\t\t\tparams,\n\t\t\t\t\tget data() {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t},\n\t\t\t\t\tset data(value) {\n\t\t\t\t\t\tif (typeof value !== \"object\" || value === null) {\n\t\t\t\t\t\t\tthrow new Error(\"context.data must be an object\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// user has overriden context.data, so we need to merge it with the existing data\n\t\t\t\t\t\tdata = value;\n\t\t\t\t\t},\n\t\t\t\t\tenv,\n\t\t\t\t\twaitUntil: workerContext.waitUntil.bind(workerContext),\n\t\t\t\t\tpassThroughOnException: () => {\n\t\t\t\t\t\tisFailOpen = true;\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tconst response = await handler(context);\n\n\t\t\t\tif (!(response instanceof Response)) {\n\t\t\t\t\tthrow new Error(\"Your Pages function should return a Response\");\n\t\t\t\t}\n\n\t\t\t\treturn cloneResponse(response);\n\t\t\t} else if (__FALLBACK_SERVICE__) {\n\t\t\t\t// There are no more handlers so finish with the fallback service (`env.ASSETS.fetch` in Pages' case)\n\t\t\t\tconst response = await env[__FALLBACK_SERVICE__].fetch(request);\n\t\t\t\treturn cloneResponse(response);\n\t\t\t} else {\n\t\t\t\t// There was not fallback service so actually make the request to the origin.\n\t\t\t\tconst response = await fetch(request);\n\t\t\t\treturn cloneResponse(response);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\treturn await next();\n\t\t} catch (error) {\n\t\t\tif (isFailOpen) {\n\t\t\t\tconst response = await env[__FALLBACK_SERVICE__].fetch(request);\n\t\t\t\treturn cloneResponse(response);\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t},\n};\n\n// This makes a Response mutable\nconst cloneResponse = (response: Response) =>\n\t// https://fetch.spec.whatwg.org/#null-body-status\n\tnew Response(\n\t\t[101, 204, 205, 304].includes(response.status) ? null : response.body,\n\t\tresponse\n\t);\n", "/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\", delimiter = \"/#?\" } = options;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  const isSafe = (value: string): boolean => {\n    for (const char of delimiter) if (value.indexOf(char) > -1) return true;\n    return false;\n  };\n\n  const safePattern = (prefix: string) => {\n    const prev = result[result.length - 1];\n    const prevText = prefix || (prev && typeof prev === \"string\" ? prev : \"\");\n\n    if (prev && !prevText) {\n      throw new TypeError(\n        `Must have text between two parameters, missing text after \"${(prev as Key).name}\"`,\n      );\n    }\n\n    if (!prevText || isSafe(prevText)) return `[^${escapeString(delimiter)}]+?`;\n    return `(?:(?!${escapeString(prevText)})[^${escapeString(delimiter)}])+?`;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || safePattern(prefix),\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? safePattern(prefix) : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions,\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {},\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`,\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string,\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions,\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {},\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {},\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            throw new TypeError(\n              `Can not repeat \"${token.name}\" without a prefix and suffix`,\n            );\n          }\n\n          route += `(${token.pattern})${token.modifier}`;\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n"],
  "mappings": "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",
  "names": ["exports", "end", "index", "length", "match", "token", "next", "parse", "line", "luaparse", "value", "_a", "result", "char", "prefix", "i"]
}
